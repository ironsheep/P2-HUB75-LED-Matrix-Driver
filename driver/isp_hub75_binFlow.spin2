'' =================================================================================================
''
''   File....... isp_hub75_binFlow.spin2
''   Purpose.... Animate a single flow input or output for Binary water Clock
''   Authors.... Stephen M Moraco
''               -- Copyright (c) 2020 Iron Sheep Productions, LLC
''               -- see below for terms of use
''   E-mail..... stephen@ironsheep.biz
''   Started.... Oct 2020
''   Updated.... 24 Oct 2020
''
'' =================================================================================================

' NOTE: this object is built to be any in-flow or out-flow for any digit
'   However, it can't do more than one flow at a time
'   A flow exists from the time an inflow occurs to the time it becomes an outflow and it leaves the display

CON { constants affecting appearance }

    MAX_LENGTH_OF_FLOW = 7                           ' for every two inputs raise 1 line, for every two outputs lower 1 line
    MAX_LENGTH_OF_QUEUE = MAX_LENGTH_OF_FLOW + 2     ' +2: allow max length without queue being full

    MAX_SIMULTANEOUS_FEEDS = 14 + 1 ' should only ever have 14:  hours=1+3, minutes=2+3, seconds=2+3 (add 1 extra)

    INDEX_NOT_FOUND = -1

    ' flow movement commands
    #0,DIR_UNKNOWN, DIR_DOWN, DIR_RIGHT, DIR_UP, DIR_LEFT, DIR_DONE, SET_ROW, SET_COL, EAT_TAIL

    ' digit index value names
    #0, DIGIT_HOURS_TENS, DIGIT_HOURS_ONES, DIGIT_MINUTES_TENS, DIGIT_MINUTES_ONES, DIGIT_SECONDS_TENS, DIGIT_SECONDS_ONES

    START_ROW = -1   ' off screen
    START_COLUMN = 59

    END_ROW = 31
    END_COLUMN = 63 

    FLOW_1_COLOR = $00592E
    FLOW_2_COLOR = $002EB9
    FLOW_3_COLOR = $00D117
    FLOW_4_COLOR = $00B9B9

OBJ

    hardware                : "isp_hub75_hwGeometry"
    color                   : "isp_hub75_color"

DAT { initialized data }
    ' flow route descriptions
inflowS018  byte    DIR_DOWN, 3
            byte    DIR_LEFT, 5
            byte    DIR_DOWN, 5
            byte    DIR_RIGHT, 1
            byte    EAT_TAIL, 0
            byte    DIR_DONE, 0

inflowS014  byte    DIR_DOWN, 3
            byte    DIR_LEFT, 5
            byte    DIR_DOWN, 11
            byte    DIR_RIGHT, 1
            byte    EAT_TAIL, 0
            byte    DIR_DONE, 0

inflowS012  byte    DIR_DOWN, 3
            byte    DIR_LEFT, 5
            byte    DIR_DOWN, 17
            byte    DIR_RIGHT, 1
            byte    EAT_TAIL, 0
            byte    DIR_DONE, 0

inflowS011  byte    DIR_DOWN, 3
            byte    DIR_LEFT, 5
            byte    DIR_DOWN, 23
            byte    DIR_RIGHT, 1
            byte    EAT_TAIL, 0
            byte    DIR_DONE, 0

outflowS018 byte    SET_ROW, 7
            byte    SET_COL, 61
            byte    DIR_RIGHT, 1
            byte    DIR_DOWN, 24
            byte    DIR_RIGHT, 1
            byte    EAT_TAIL, 0
            byte    DIR_DONE, 0

outflowS014 byte    SET_ROW, 13
            byte    SET_COL, 61
            byte    DIR_RIGHT, 1
            byte    DIR_DOWN, 18
            byte    DIR_RIGHT, 1
            byte    EAT_TAIL, 0
            byte    DIR_DONE, 0

outflowS012 byte    SET_ROW, 19
            byte    SET_COL, 61
            byte    DIR_RIGHT, 1
            byte    DIR_DOWN, 12
            byte    DIR_RIGHT, 1
            byte    EAT_TAIL, 0
            byte    DIR_DONE, 0

outflowS011 byte    SET_ROW, 25
            byte    SET_COL, 61
            byte    DIR_RIGHT, 1
            byte    DIR_DOWN, 7
            byte    DIR_RIGHT, 1
            byte    EAT_TAIL, 0
            byte    DIR_DONE, 0

' we need to detect overlaps
' one simple approach is to keep a list of all occuppied locations

' this will be an unusual list as well use a max length
' but we'll also allow items to be removed from the middle of the 
' list so entries will be empty and then early reused
' it will also be an unorderd list - Entry Sequence but affected by reuse
' point of the max used count is to reduce search times when possible

' each entry is a long containing { row, col, count }

activeLocations long    0[MAX_SIMULTANEOUS_FEEDS * MAX_LENGTH_OF_FLOW]
activeLocnCount byte    0

runUnitTest     byte    FALSE   ' no need to run for now...


VAR { globals }
    ' single flow state
    long    headRow
    long    headCol
    long    headCount
    long    seqIndex

' target screen and geometry thereof
    long    pExtScreen
    long    maxBitRows
    long    maxBitColumns
    long    defaultColor
    
    long    pCurrFlowTable
    long    drip[MAX_LENGTH_OF_QUEUE]
    byte    dripHead
    byte    dripTail
    byte    dripEntryCount

    byte    dripCommand
    byte    dripRemaining
    byte    dripEntryIndex

    byte    isSetup

PUB null()
    '' This is NOT a top level object

PUB setScreen(pScreen)
    '' Save the location of our external screen buffer
    'debug("7s:setScreen")
    pExtScreen := pScreen
    maxBitColumns := hardware.MAX_PANEL_COLUMNS
    maxBitRows := hardware.MAX_PANEL_ROWS
    if not isSetup
        initialize()
        if runUnitTest
            testNewActiveTracking()
            runUnitTest := FALSE

PUB startFlow(digitId, fmNybble, toNybble) | bitIndex, bitMask, diffCount, liveIndex, zerosCount
    '' start (1 to 6) * (1 to 4) flows at the same time : h10(2,1), h01(8,4,2,1), m10(4,2,1), m01(8,4,2,1), s10(4,2,1), s01(8,4,2,1)
    if not isMovementComplete()
        debug("flo:start - IGNORED already moving")
    else
        diffCount := 0
        repeat bitIndex from 0 to 3
            bitMask := 1 << bitIndex
            if fmNybble & bitMask <> toNybble & bitMask
                diffCount++
        if diffCount > 1
            debug("ERROR ERROR more than 1 bit selected for nybble! Abort")
            abort
        elseif diffCount == 0
            debug("ERROR no FLOW requested and nothing to clear! Abort")
            abort

        ' initiate the single flow
        initiateFlows(digitId, fmNybble, toNybble)

PRI initiateFlows(digitId, fmNybble, toNybble)
    case digitId
        DIGIT_HOURS_TENS:
        DIGIT_HOURS_ONES:
        DIGIT_MINUTES_TENS:
        DIGIT_MINUTES_ONES:
        DIGIT_SECONDS_TENS:
        DIGIT_SECONDS_ONES:
            if fmNybble & 8 <> toNybble & 8
                ' something changed, update our display
                if (fmNybble & 8) > 0
                    ' our 8 flow is one, turning off - outflow
                    initiateFlow(@outflowS018)
                else 
                    ' our 8 flow is off turning on - inflow
                    headRow := START_ROW
                    headCol := START_COLUMN
                    initiateFlow(@inflowS018)

            if fmNybble & 4 <> toNybble & 4
                ' something changed, update our display
                if (fmNybble & 4) > 0
                    ' our 4 flow is one, turning off - outflow
                    initiateFlow(@outflowS014)
                else 
                    ' our 4 flow is off turning on - inflow
                    headRow := START_ROW
                    headCol := START_COLUMN
                    initiateFlow(@inflowS014)

            if fmNybble & 2 <> toNybble & 2
                ' something changed, update our display
                if (fmNybble & 2) > 0
                    ' our 2 flow is one, turning off - outflow
                    initiateFlow(@outflowS012)
                else 
                    ' our 2 flow is off turning on - inflow
                    headRow := START_ROW
                    headCol := START_COLUMN
                    initiateFlow(@inflowS012)

            if fmNybble & 1 <> toNybble & 1
                ' something changed, update our display
                if (fmNybble & 1) > 0
                    ' our 1 flow is one, turning off - outflow
                    initiateFlow(@outflowS011)
                else 
                    ' our 1 flow is off turning on - inflow
                    headRow := START_ROW
                    headCol := START_COLUMN
                    initiateFlow(@inflowS011)
        OTHER:
            debug("ERROR! Bad digit selector - initiateFlows(), aborted")
            abort 

PUB isInUse() : inUseStatus 
    '' return T/F where T means this flow has bits on the board...
    ' now let's check for any nibbles being set (meaning we did inflow but now outflow)

    ' if we've a nybble set or we still moving this flow is in use
    inUseStatus := (dripCommand == DIR_DONE || dripCommand == DIR_UNKNOWN) ? FALSE : TRUE
    debug("flo:check ", udec(inUseStatus), udec(dripCommand))

PUB isMovementComplete() : status
    '' Return T/F where T means that all movement for this bit is complete
    status := (dripCommand == DIR_DONE || dripCommand == DIR_UNKNOWN)

PUB animateStep() 
    '' Do one animation step, if one is pending
    if not isMovementComplete()
        moveDrip()

PRI initiateFlow(pFlowTable) | command, distance
    ' load first command, make initial move
    pCurrFlowTable := pFlowTable
    dripEntryIndex := 0
    dripCommand, dripRemaining := nextCommand()
    if not isMovementComplete()
        moveDrip()

PRI nextCommand() : command, distance | pCurrEntry
    ' return indexed command and point to next
    pCurrEntry := @byte[pCurrFlowTable][dripEntryIndex * 2]
    command := byte[pCurrEntry][0]
    distance := byte[pCurrEntry][1]
    debug("flo:next ", udec(command), udec(distance))
    dripEntryIndex++


PRI moveDrip() | moved, haveRow, haveColumn, finishedCommand, placeNew, tailRow, tailCol, removeTail, howMany, tailColor, headColor
    moved := FALSE
    finishedCommand := FALSE
    haveRow := FALSE
    haveColumn := FALSE
    removeTail := FALSE
    repeat
        ' show a new head bit, if max bits are showing hide a tail bit
        case dripCommand
            SET_ROW:
                headRow := dripRemaining
                haveRow := TRUE
                finishedCommand := TRUE
            SET_COL:
                headCol := dripRemaining
                haveColumn := TRUE
                finishedCommand := TRUE
            DIR_DOWN:
                headRow++
                moved := TRUE
            DIR_RIGHT:
                headCol++
                moved := TRUE
            DIR_UP:
                headRow--
                moved := TRUE
            DIR_LEFT:
                headCol--
                moved := TRUE
            EAT_TAIL:
                moved := TRUE
                removeTail := TRUE
                dripRemaining := dripEntryCount + 1
            OTHER:
                debug("dig: bad drip command (", udec_(dripCommand), ")")

        if moved
            dripRemaining--
            if dripRemaining == 0
                finishedCommand := TRUE
        if haveRow && haveColumn
            moved := TRUE
        if finishedCommand
            dripCommand, dripRemaining := nextCommand()
    while not moved

    if not removeTail
        howMany := activateLocation(headRow, headCol)
        headColor := colorForCount(howMany)
        ' place bit at row,col
        drawPixelAtRCwithRGB(headRow, headCol, color.rgbForCValue(headColor))
        ' add to queue
        pushHeadBit(headRow, headCol)
        'debug("flo:moved headRC=(", udec_(headRow), udec_(headCol), ") ct=", udec_(dripEntryCount))

    ' if at max entries remove a bit, freeing queue entry
    if dripEntryCount >= MAX_LENGTH_OF_FLOW || removeTail
        if dripEntryCount > 0
            tailRow, tailCol := popTailBit()
            howMany := deactivateLocation(tailRow, tailCol)
            tailColor := colorForCount(howMany)
            drawPixelAtRCwithRGB(tailRow, tailCol, color.rgbForCValue(tailColor))

PRI colorForCount(howMany) : rgbColor
    case howMany
        1: rgbColor := FLOW_1_COLOR
        2: rgbColor := FLOW_2_COLOR
        3: rgbColor := FLOW_3_COLOR
        4: rgbColor := FLOW_4_COLOR
        OTHER:
            rgbColor := color.cBlack

PRI locateLocationMatch(row, col) : foundIndex | pEntry, currValue, listIndex, word highWord, word huntWord 
    foundIndex := INDEX_NOT_FOUND
    if activeLocnCount <> 0
        huntWord := ((row & $ff) << 8) | (col & $ff)
        repeat listIndex from 0 to activeLocnCount
            pEntry := @long[@activeLocations][listIndex]
            ' ENTRY: row,col,count = $rrcc--##
            currValue := long[pEntry][0]
            'debug("- checking ", uhex_long(currValue))
            highWord := (currValue) >> 16 & $ffff
            if highWord == huntWord
                foundIndex := listIndex
                quit    ' abort we have our answer
    'debug("- flo:loc RC=(", udec_(row), ", ", udec_(col), ") ", sdec(foundIndex), uhex_long(currValue))

PRI locate1stEmptyOrNewLastEntry() : foundIndex | listIndex
    foundIndex := activeLocnCount
    if activeLocnCount > 0
        ' find earliest empty entry or just add new
        repeat listIndex from 0 to activeLocnCount
            if long[@activeLocations][listIndex] == 0
                foundIndex := listIndex
                quit    ' outta here we have our answer
        ' if there are no empty slots in list, point to new location at end and incre list len
    if foundIndex == activeLocnCount
        activeLocnCount++
    'debug("- flo:neA ", sdec(foundIndex), udec(activeLocnCount))

PRI activateLocation(row, col) : count | listIndex, newEntry, addEntry, currEntry
    addEntry := FALSE
    if activeLocnCount == 0
        addEntry := TRUE
    else
        listIndex := locateLocationMatch(row, col)
        if listIndex == INDEX_NOT_FOUND
            addEntry := TRUE
        else
            ' adjust existing entry
            currEntry := long[@activeLocations][listIndex]
            count := currEntry & $ff
            count++
            currEntry := (currEntry & $ffffff00) | count
            long[@activeLocations][listIndex] := currEntry
            newEntry := currEntry   ' to facilitate debug

    if addEntry
        ' add new entry
        count := 1
        ' ENTRY: row,col,count = $rrcc--##
        newEntry := ((row & $ff) << 24) | ((col & $ff) << 16) | count
        listIndex := locate1stEmptyOrNewLastEntry()
        long[@activeLocations][listIndex] := newEntry
    'debug("flo:act RET(", udec_(count), ") active[", udec_(listIndex), "] <= (", uhex_long_(newEntry), ")  Len=(", udec_(activeLocnCount), ")")

PRI deactivateLocation(row, col) : count | listIndex, currEntry, removeEntry, indexUsed, oldEntry, startingActiveCount
    count := 0
    indexUsed := -1
    if activeLocnCount > 0
        listIndex := locateLocationMatch(row, col)
        if listIndex <> INDEX_NOT_FOUND
            ' adjust existing entry
            ' ENTRY: row,col,count = $rrcc--##
            currEntry := long[@activeLocations][listIndex]
            oldEntry := currEntry   ' for debug
            count := currEntry & $ff
            count--
            currEntry := (currEntry & $ffffff00) | count
            ' if no more overlap...
            if count == 0
                ' wipe out this entry
                currEntry := 0
            indexUsed := listIndex
            long[@activeLocations][listIndex] := currEntry
            ' if we just wiped out the end-most entry then reduce our count of entries.. by all empty locations at tail
            if listIndex == activeLocnCount - 1
                startingActiveCount := activeLocnCount
                repeat listIndex from  startingActiveCount - 1 to 0
                    if long[@activeLocations][listIndex] == 0   
                        activeLocnCount--
                    else
                        quit    ' some are not empty, don't check further
                ' and show that index we used no longer exists
                indexUsed := -1

    'debug("flo:dea RET(", udec_(count), "), val=(", uhex_long_(currEntry), ") <= active[", sdec_(indexUsed), "] was:[", uhex_long_(oldEntry), "]  Len=(", udec_(activeLocnCount), ")")

PRI testNewActiveTracking() | didFail, retCount
    debug("-- TEST start -- ")
    didFail := FALSE
    didFail |= testEnsureActiveEmpty()
    retCount := activateLocation(1,2)
    didFail |= testEnsureReturnedCount(retCount, 1)
    didFail |= testEnsureActive(1)
    retCount := deactivateLocation(1,2)
    didFail |= testEnsureReturnedCount(retCount, 0)
    didFail |= testEnsureActiveEmpty()

    retCount := activateLocation(2,2)
    didFail |= testEnsureReturnedCount(retCount, 1)
    retCount := activateLocation(2,3)
    didFail |= testEnsureReturnedCount(retCount, 1)
    didFail |= testEnsureActive(2)
    retCount := deactivateLocation(2,2)
    didFail |= testEnsureReturnedCount(retCount, 0)
    didFail |= testEnsureActive(2)
    retCount := deactivateLocation(2,3)
    didFail |= testEnsureReturnedCount(retCount, 0)
    didFail |= testEnsureActiveEmpty()

    retCount := activateLocation(3,3)
    didFail |= testEnsureReturnedCount(retCount, 1)
    didFail |= testEnsureActive(1)
    retCount := activateLocation(3,3)
    didFail |= testEnsureReturnedCount(retCount, 2)
    didFail |= testEnsureActive(1)
    retCount := deactivateLocation(3,3)
    didFail |= testEnsureReturnedCount(retCount, 1)
    didFail |= testEnsureActive(1)
    retCount := deactivateLocation(3,3)
    didFail |= testEnsureReturnedCount(retCount, 0)
    didFail |= testEnsureActiveEmpty()

    if didFail
        debug(" ---> FAILED")
    else
        debug(" ---> ALL TEST PASSED!")

    debug("-- TEST end -- ")

PRI testEnsureActiveEmpty() : failed | currEntry
    failed := FALSE
    if activeLocnCount <> 0
        debug("- ERROR active NOT empty:", udec(activeLocnCount))
        failed := TRUE
    currEntry := long[@activeLocations][0]
    if currEntry <> 0
        debug("- ERROR 1st entry NOT empty:", udec(currEntry))
        failed := TRUE

PRI testEnsureActive(activeCount) : failed
    failed := FALSE
    if activeLocnCount <> activeCount
        debug("- ERROR active count(", udec_(activeLocnCount), "), expected(", udec_(activeCount), ")")
        failed := TRUE

PRI testEnsureReturnedCount(actualCount, expectedCount) : failed
    failed := FALSE
    if actualCount <> expectedCount
        debug("- ERROR BAD return value: actual(", udec_(actualCount), ") <> (", udec_(expectedCount), ")")
        failed := TRUE

PRI pushHeadBit(row, col) | rcLong, saveHead
    rcLong := (row << 16) | col
    if dripHead + 1 == dripTail
        debug("fullQueue - abort")
        abort     
    saveHead := dripHead
    drip[dripHead] := rcLong
    dripHead++ 
    dripEntryCount++
    if dripHead > MAX_LENGTH_OF_QUEUE - 1
        dripHead := 0
    'debug("flo:push queue[", udec_(saveHead), "] <= (", uhex_long_(rcLong), ")  newHead=(", udec_(dripHead), ")")

PRI popTailBit() : row, col | rcLong, saveTail
    if dripHead == dripTail
        debug("emptyQueue - abort")
        abort 
    saveTail := dripTail
    rcLong := drip[dripTail]
    row := (rcLong >> 16) & $ff
    col :=  rcLong        & $ff
    dripTail++ 
    dripEntryCount--
    if dripTail > MAX_LENGTH_OF_QUEUE - 1
        dripTail := 0
    'debug("flo:pop val=(", uhex_long_(rcLong), ") <= queue[", udec_(saveTail), "]  newTail=(", udec_(dripTail), ")")

PRI initialize() | digitIndex
    isSetup := TRUE
    dripCommand := DIR_UNKNOWN
    headRow := headCol := dripEntryCount := 0
    dripTail := dripHead := 0

PRI drawPixelAtRCwithRGB(row, column, red, green, blue) | rowIndex, columnIndex, colorOffset, pColor
    '' Place r,g,b colored pixel at r,c
    rowIndex := 0 #> row <# maxBitRows - 1
    columnIndex :=  0 #> column <# maxBitColumns - 1
    colorOffset := ((rowIndex * maxBitColumns) + columnIndex) * hardware.DISPLAY_BYTES_PER_COLOR
    pColor := @byte[pExtScreen][colorOffset]
    'if isDebugLocn(rowIndex, columnIndex)
    'debug("flo:Screen RC=(", udec_(rowIndex), ", ", udec_(columnIndex), "), ofs=", udec_(colorOffset), ", RGB=(", uhex_(red), uhex_(green), uhex_(blue), ")")
    byte[pColor][0] := color.correctedColor(red)
    byte[pColor][1] := color.correctedColor(green)
    byte[pColor][2] := color.correctedColor(blue)
    
CON { license }

{{


 -------------------------------------------------------------------------------------------------
  MIT License

  Copyright (c) 2020 Iron Sheep Productions, LLC

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
 =================================================================================================
 
}}

