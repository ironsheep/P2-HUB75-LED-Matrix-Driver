{{
    SCREEN buffer in HUB RAM
        LATCH 3-clock as last 3 of 64 columns

        ADDR change first (during /LATCH, OE before LATCH CLOCKS)
                - OR - (comment out 1 or other form)
        ADDR change last (during /LATCH, OE afer LATCH CLOCKS)
}}

CON { timing }

  CLK_FREQ = 335_000_000                                        ' system freq as a constant
  MS_001   = CLK_FREQ / 1_000                                   ' ticks in 1ms
  US_001   = CLK_FREQ / 1_000_000                               ' ticks in 1us

  NS_015   = 5 ' - 2 '15 / (1_000_000_000 / CLK_FREQ)                   ' tics in 15 nSec
  NS_030   = 10 - 2 '30 / (1_000_000_000 / CLK_FREQ)            ' tics in 30 nSec

  BR_TERM  = 2_000_000                                          ' debug baud rate

  _clkfreq = CLK_FREQ                                           ' set system clock

CON { I/O PINs }

'DEBUG_PIN = 16

MTX_LED_PIN_R1 = 47
MTX_LED_PIN_G1 = 46
MTX_LED_PIN_B1 = 45

MTX_LED_PIN_R2 = 43
MTX_LED_PIN_G2 = 42
MTX_LED_PIN_B2 = 41

MTX_LED_PIN_D = 39
MTX_LED_PIN_C = 38
MTX_LED_PIN_B = 37
MTX_LED_PIN_A = 36

MTX_LED_PIN_LATCH = 34
MTX_LED_PIN_OE = 33
MTX_LED_PIN_CLK = 32

MTX_ROW_ADDR_PINS = MTX_LED_PIN_A ADDPINS 3
MTX_LT_COLOR_PINS = MTX_LED_PIN_B1 ADDPINS 2
MTX_RT_COLOR_PINS = MTX_LED_PIN_B2 ADDPINS 2
MTX_CTL_PINS      = MTX_LED_PIN_CLK ADDPINS 2

CON { Data }

    WAIT_TIME_IN_MS = 500

    DELAY_CNT = 4

    SCREEN_BYTES = 768

' offsets in longs
    RED_OFFSET = 0
    GREEN_OFFSET = 64
    BLUE_OFFSET = 128

    MAX_COLUMNS = 64
    MAX_ROWS = 32

' bits within color
    RED_BIT = 2
    GREEN_BIT = 1
    BLUE_BIT = 0

' Colors
    BLACK   = $00
    BLUE    = $01
    GREEN   = $02
    CYAN    = $03
    RED     = $04
    MAGENTA = $05
    YELLOW  = $06
    WHITE   = $07

    #0, CMD_DONE, CMD_CLEAR, CMD_SHOW_BUFFER, CMD_FILL_COLOR, CMD_SHOW_PWM_BUFFER

VAR
    long  cog

    long  addr_pins       ' ptra[0]
    long  rgb0_pins       ' ptra[1]
    long  rgb1_pins       ' ptra[2]
    long  ptrCommand      ' ptra[3]
    long  ptrArgument     ' ptra[4]  @buffer -OR- color value [0-7]

       ' write values here to pass to driver
    long  dvrCommand
    long  dvrArgument 

' ------------------------------------------------------
PUB start() : ok            '' setup the pasm2 driver vars, then start a new cog running the driver

    stop()

    setupPins()
    resetPanel()

    ' pass values to our driver
    addr_pins := MTX_ROW_ADDR_PINS
    rgb0_pins := MTX_LT_COLOR_PINS
    rgb1_pins := MTX_RT_COLOR_PINS
    ptrCommand := @dvrCommand
    ptrArgument := @dvrArgument

    dvrCommand := CMD_DONE      ' ensure we start here

    ok := cog := coginit(16, @drive_matrix, @addr_pins) + 1
    'repeat        ' do nothing, forever (lock us up) -- for TESTING ONLY

PUB stop()                  '' stop the cog that is running the driver
  if cog
    cogstop(cog - 1)

  pinclear(MTX_ROW_ADDR_PINS)
  pinclear(MTX_ROW_ADDR_PINS)
  pinclear(MTX_ROW_ADDR_PINS)
  pinclear(MTX_CTL_PINS)

' ----------------------------------------------------------
PUB fillPanel(color) | cValue               '' request that driver fill the buffer with {color} value
    cValue := 0 #> color <# 7
    dvrArgument := cValue    ' set color value of BLACK
    dvrCommand := CMD_FILL_COLOR
    repeat while (dvrCommand <> CMD_DONE)

PUB clearPanel()                            '' request that driver fill the buffer with 0's (black)
    fillPanel(BLACK)

PUB writeBuffer(pBuffer)                    '' request that driver copy our buffer to its buffer
    dvrArgument := pBuffer
    dvrCommand := CMD_SHOW_BUFFER
    repeat while (dvrCommand <> CMD_DONE)

PUB writePwmBuffer(pBuffer)                    '' request that driver copy our buffer to its buffer
    dvrArgument := pBuffer
    dvrCommand := CMD_SHOW_PWM_BUFFER
    ' this will keep showing same PWM buffer until caller changes command!
    ' so it just returns immediately

PRI setupPins()                             '' configure Matrix Panel HUB75 pins
  ' Enable all comm & address pins as outputs, set default states:
  PINLOW(MTX_LED_PIN_CLK)
  PINLOW(MTX_LED_PIN_LATCH)
  PINHIGH(MTX_LED_PIN_OE)   ' high! (/OE)
  PINLOW(MTX_ROW_ADDR_PINS)
  PINLOW(MTX_LT_COLOR_PINS)
  PINLOW(MTX_RT_COLOR_PINS)

PRI dbgMemDump(bfrId, buffer, len) | bytBffr, colIdx, rowIdx, maxCol, maxRow
    debug("`temp 13 13 '", zstr_(bfrId), ": bffr=", uhex_long_(buffer), "(", udec_(len), ")' 13")
    maxCol := len >= 16 ? 15 : len
    maxRow := (len / 16)
    if maxRow == 0
     maxRow := 1

    bytBffr := buffer
    'returns
    repeat rowIdx from 1 to maxRow
        'if rowIdx < 10
        '  debug("`temp ' '")	' space
        debug("`temp '  ", uhex_long_(bytBffr), ": '")
        repeat colIdx from 0 to maxCol
            debug("`temp '", uhex_byte_(byte[bytBffr+colIdx]), " '")
            if colIdx == 7
                debug("`temp ' '")	' space
        bytBffr += 16
        debug("`temp 13")		' newline
        waitus(50)
    debug("`temp 13")		' newline

' ----------------------------------------------------------
CON

MAX_PINS = 64   ' 64 & 128 do not appear to be different?? - 64: 1x panel, 128: 2x panels, etc.

PRI resetPanel() | pinIdx, groupIdx                         '' write the required init sequence to our panel drivers

' REF: https://www.gitmemory.com/issue/mrfaptastic/ESP32-RGB64x32MatrixPanel-I2S-DMA/23/665659409

  PINHIGH(MTX_LED_PIN_OE)
  PINLOW(MTX_LED_PIN_LATCH)
  PINLOW(MTX_LED_PIN_CLK)

  ' Control Register 1 - LE w/11 clocks
  ' Control Register 2 - LE w/12 clocks

  ' All FM6126A code is based on the excellent guesswork by shades66 in https://github.com/hzeller/rpi-rgb-led-matrix/issues/746

  ' Register 12 - brightness/gain settings, three 6bit values, aaaaaabbbbbbcccccc a= darkness?
  '                seems to add red to the background when the leds are off, b=main brightness c=finer brightness
  '                (i'm not sure if b & c are actually as 12 bit value but with b set to all 1's the value in c doesn't seem to make much difference)

  ' Register 13 - not sure what it's doing yet, just that 1 specific bit within seems to be an overall enable function.

  ' Now set all the values at the top to the same value for each of register 12/13 to get the same settings across the panel, the
  '   current code loads different settings into each 32 columns.

  ' clocking in the register is simply clocking in the value (i've 2 panels so 128bits of data) and for the last 12/13 bits depending
  '   on the register setting the latch to high. the final drop of latch to low clocks in the configuration. this is done by sending
  '   the same value to r1/r2/g1/g2/b1/b2 at the same time to load the config into all the FM6126 chips

  ' Some necessary magic bit fields
  ' b12  - 1  adds red tinge
  ' b12  - 9/8/7/6/5  =  4 bit brightness
  ' b13  - 9   =1 screen on
  ' b13  - 6   =1 screen off

  ' NOTES from code:
  '                 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1
  '                 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
  '  int C12[16] = {0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}; // HIGH *NOTE* from https://github.com/2dom/PxMatrix/blob/master/PxMatrix.h#L372
  '  int C12[16] = {0,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1}; // LOW
  '  int C13[16] = {0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0};

  ' send data to Control Register 11
  repeat pinIdx from 0 to MAX_PINS - 1
     groupIdx := pinIdx // 16
     if groupIdx == 0
       PINLOW(MTX_LT_COLOR_PINS)
       PINLOW(MTX_RT_COLOR_PINS)
     else
       PINHIGH(MTX_LT_COLOR_PINS)
       PINHIGH(MTX_RT_COLOR_PINS)

     ' mark the data
     if pinIdx > (MAX_PINS - 12)
       PINHIGH(MTX_LED_PIN_LATCH)
     else
       PINLOW(MTX_LED_PIN_LATCH)

     ' clock the data
     PINHIGH(MTX_LED_PIN_CLK)
     PINLOW(MTX_LED_PIN_CLK)

  ' end reg 11 setup
  PINLOW(MTX_LED_PIN_LATCH)

  ' send data to Control Register 12
  repeat pinIdx from 0 to MAX_PINS - 1
     groupIdx := pinIdx // 16
     if groupIdx <> 9
       PINLOW(MTX_LT_COLOR_PINS)
       PINLOW(MTX_RT_COLOR_PINS)
     else
       PINHIGH(MTX_LT_COLOR_PINS)
       PINHIGH(MTX_RT_COLOR_PINS)

     ' mark the data
     if pinIdx > (MAX_PINS - 13)
       PINHIGH(MTX_LED_PIN_LATCH)
     else
       PINLOW(MTX_LED_PIN_LATCH)

     ' clock the data
     PINHIGH(MTX_LED_PIN_CLK)
     PINLOW(MTX_LED_PIN_CLK)

  ' end reg 12 setup
  PINLOW(MTX_LED_PIN_LATCH)
  PINLOW(MTX_LED_PIN_OE)

' theory  3 bits per pixel
'  2048 pixels
'  8 sections [0-7]: 256 pixels / section
'  2 sides: 1024 pixels / side - / 8 sections: 128 pixels / section
' EA side: 1024 pixels
' EA side section 128 pixels

DAT     { driver assembly code }
                    org     0       ' COG code


' ----------------------------------------------------------
'
' DRAFT matrix driver - best speed
'
drive_matrix
                    stalli    ' disable interrupts
                    mov     ijmp1, #isr1
                    mov     ijmp2, #isr2
                    mov     ijmp3, #isr3
                    allowi    ' enable interrupts
                    rdlong  addr_bus, ptra[0]
                    rdlong  rgb0_bus, ptra[1]
                    rdlong  rgb1_bus, ptra[2]
                    rdlong  pCommmand, ptra[3]
                    rdlong  pArgument, ptra[4]

                    drvl    rgb0_bus
                    drvl    rgb1_bus
                    drvl    addr_bus

                    drvl    #MTX_LED_PIN_CLK
                    drvl    #MTX_LED_PIN_LATCH
                    drvl    #MTX_LED_PIN_OE

                    mov     pwmFrameCt, #0  ' initial setup: NOT doing PWM

' clear screen color - RED/GREEN
                    drvl #MTX_LED_PIN_R1
                    drvl #MTX_LED_PIN_G1
                    drvl #MTX_LED_PIN_B1
                    drvl #MTX_LED_PIN_R2
                    drvl #MTX_LED_PIN_G2
                    drvl #MTX_LED_PIN_B2

' init row address
                    mov     row_addr, #15

' write address
                    call    #emitAddr
                    'call    #dumpTwinRows

wrFrame
                    'new PWM support
                    cmp     pwmFrameCt, #0  wz
    if_nz           jmp     #nextPwmFrame
                    rdlong  nxtCommand, pCommmand
                    rdlong  nxtArgument, pArgument
                    cmp     nxtCommand, #CMD_DONE  wz
    if_z            jmp     #chksDone  ' redraw current buffer  
                    debug("* cmd=", udec_(nxtCommand), ", arg=", uhex_long_(nxtArgument))
chkShow
                    cmp     nxtCommand, #CMD_SHOW_BUFFER    wz
    if_nz           jmp     #chkShowPwm
                    call    #loadBuffer
                    debug(" - load done")
                    jmp     #markCmdComplete  ' redraw current buffer  
chkShowPwm
                    cmp     nxtCommand, #CMD_SHOW_PWM_BUFFER    wz
    if_nz           jmp     #chkFill
                    call    #loadPwmBuffers
                    debug(" - PWM frame done")
                    jmp     #wrFrame          ' check for next command (or same still there)
chkFill
                    cmp     nxtCommand, #CMD_FILL_COLOR wz
    if_nz           jmp     #chksDone  ' redraw current buffer                
                    call    #fillBuffer
                    debug(" - fill done")
                    jmp     #markCmdComplete  ' redraw current buffer
'
' loadPwmBuffers(nxtArgument=hubAddressOfPWMFrameSet)
'
loadPwmBuffers
                    mov     pwmBffrStart, nxtArgument   ' preserve our new start address
                    mov     pwmFrameCt, #8              ' set loop to PWM 8 frames then stop to see what to do next
showPwmFrame
                    call    #loadBuffer ' load the current frame into display buffer
                    jmp     #wrCurrent  ' display it
nextPwmFrame
                    add     nxtArgument,##768    ' point to next frame
                    djnz    pwmFrameCt, #showPwmFrame   ' have onother of the 8 to show?
                    mov     nxtArgument, pwmBffrStart   ' no point back to first of 8 buffers
                    ret                                 ' loop again to see if we should do another PWM set
'
' loadBuffer(nxtArgument=hubAddressOfFrame)
'
loadBuffer
                    ' copy HUB buffer pointed to by nxtArgument to display buffer
                    mov     ptrb, nxtArgument
                    mov     fillOffset, #0
                    mov     fillCount, #192 'length in longs
ldLoop1
                    altd    fillOffset, #screenBffr
                    rdlong	0-0,ptrb++
                    add     fillOffset, #1
                    djnz    fillCount, #ldLoop1
                    ' return
                    ret
'
' fillBuffer(nxtArgument=colorvalue3bit)
'
fillBuffer      ' fill panel buffer based on desired color
                    mov     fillOffset, #RED_OFFSET
                    testbn  nxtArgument, #RED_BIT   wz
                    call    #setBuffer
                    mov     fillOffset, #GREEN_OFFSET
                    testbn  nxtArgument, #GREEN_BIT   wz
                    call    #setBuffer
                    mov     fillOffset, #BLUE_OFFSET
                    testbn  nxtArgument, #BLUE_BIT   wz
                    call    #setBuffer
                    'call    #dumpTwinRows
                    ret
'
' setBuffer(fillOffset, Z=fillValueID)
'
setBuffer       ' fill red, green or blue buffer with desired long value
                    muxnz   fillLong, kAllOnes  ' fill with $0000_0000 or $FFFF_FFFF based on Z
                    mov     fillCount, #64
nextSet
                    altd    fillOffset, #screenBffr
                    mov     0-0, fillLong   '  fill long with value
                    add     fillOffset, #1
                    djnz    fillCount, #nextSet
                    ret

dumpTwinRows
                    debug(" Red TL,R ", uhex_long_(screenBffr+0), ", ", uhex_long_(screenBffr+1))
                    debug(" Red BL,R ", uhex_long_(screenBffr+62), ", ", uhex_long_(screenBffr+63))
                    debug(" Grn TL,R ", uhex_long_(screenBffr+64), ", ", uhex_long_(screenBffr+65))
                    debug(" Grn BL,R ", uhex_long_(screenBffr+126), ", ", uhex_long_(screenBffr+127))
                    debug(" Blu TL,R ", uhex_long_(screenBffr+128), ", ", uhex_long_(screenBffr+129))
                    debug(" Blu BL,R ", uhex_long_(screenBffr+190), ", ", uhex_long_(screenBffr+191))
                    ret

chksDone
                    cmp     nxtCommand, #CMD_DONE  wz
    if_z            jmp     #wrCurrent  ' redraw current buffer  
                    debug("--> *ERROR* Unknown cmd(", udec_(nxtCommand), ")   arg=", uhex_long_(nxtArgument))
markCmdComplete
                    'debug(" - unknown cmd done")
                    wrlong  #CMD_DONE, pCommmand    ' signal command completed
wrCurrent
                    ' repeat the following forever
                    ' set addr to start
                    mov     row_addr, #15
                    mov     row_ctr, #16            ' 16 -> 0 so we can use djnz
                    mov     reg_offset, #0          ' long[0-31] within red/grn/blu buffer
                    mov     bit_offset, #31
                    drvl    #MTX_LED_PIN_OE

' for row address 0 to 15
wrLine
'   for bit 0 to 63
'     toggle clock (18MHz)
                ' this tracks when we need to toggle latch at right-edge of row
                    mov     col_ctr, #64            ' 64 -> 0 so we can use djnz
clkData
                ' in buffer: RGB1 is reg 0-31, RGB2 is reg 32-63
                ' NOTE what does this look like with ALTB use?
                    altd    reg_offset, #redBffr
                    testb   0-0, bit_offset wz
                    drvz    #MTX_LED_PIN_R1
                    altd    reg_offset, #redBffr2
                    testb   0-0, bit_offset wz
                    drvz    #MTX_LED_PIN_R2
                    altd    reg_offset, #grnBffr
                    testb   0-0, bit_offset wz
                    drvz    #MTX_LED_PIN_G1
                    altd    reg_offset, #grnBffr2
                    testb   0-0, bit_offset wz
                    drvz    #MTX_LED_PIN_G2
                    altd    reg_offset, #bluBffr
                    testb   0-0, bit_offset wz
                    drvz    #MTX_LED_PIN_B1
                    altd    reg_offset, #bluBffr2
                    testb   0-0, bit_offset wz
                    drvz    #MTX_LED_PIN_B2
                    waitx   #NS_015 ' let color settle

' time to begin latch?
                    cmp     col_ctr, #3     wz      ' at last three columns?
    if_z            drvh    #MTX_LED_PIN_OE
    if_z            waitx   #NS_015 + 1             ' let /OE settle
    if_z            drvh    #MTX_LED_PIN_LATCH
    if_z            waitx   #NS_015 + 1             ' let LATCH settle

                    ' toggle clock
                    drvh    #MTX_LED_PIN_CLK
                    waitx   #NS_015
                    drvl    #MTX_LED_PIN_CLK
                    waitx   #NS_015

                    ' setup for next column
                    add     col_addr, #1
                    sub     bit_offset, #1  wc      ' cy=1 at start of next 32 bits (middle of row, or start of next row)
    if_c            mov     bit_offset, #31         ' bits: msb=31 (2^31) to lsb=0 (2^0)
    if_c            add     reg_offset, #1
                    djnz    col_ctr, #clkData

' LATCH DATA complete...
                drvl    #MTX_LED_PIN_LATCH      ' end latch data
                waitx   #NS_015 + 1             ' let LATCH settle

        ' write address AFTER
                add     row_addr, #1
                call    #emitAddr

                drvl    #MTX_LED_PIN_OE         ' enable output
                waitx   #NS_015 + 1
'
' wait for inter-line gap
'
                'waitx  #((US_001 - 70) / 2) - 39       ' GAP End of LINE ~528 nSec
                'waitx  #(US_001 / 8)                   ' GAP End of LINE ~372 nSec
                waitx   #(US_001 / 16)                  ' GAP End of LINE ~310 nSec
                djnz    row_ctr, #wrLine
                drvh    #MTX_LED_PIN_OE         ' disable output (between frames)

'
' wait for inter-frame gap
'
                'rep    #1, #25                 ' GAP end of FRAME ~25 uSec 0.87 Amp
                'rep    #1, #100                ' GAP end of FRAME ~100.942 uSec 1.19 Amp
                waitx   #US_001                 ' GAP end of FRAME ~1.345 uSec 0.74 Amp
.wrFrameEnd
                jmp     #wrFrame

' ----------------------------------------------------------
' subroutines
'
emitAddr
                ' write address
                testb   row_addr, #3    wc      ' bit 2^3
                drvc    #MTX_LED_PIN_D
                testb   row_addr, #2    wc      ' bit 2^2
                drvc    #MTX_LED_PIN_C
                testb   row_addr, #1    wc      ' bit 2^1
                drvc    #MTX_LED_PIN_B
                testb   row_addr, #0    wc      ' bit 2^0
                drvc    #MTX_LED_PIN_A
                waitx   #NS_015 + 1     ' let addr stabilize
                ret


isr1
                nop
                reti1
isr2
                nop
                reti2
isr3
                nop
                reti3
               

'DAT    { data }

' initialized data
'
loop_1000_ct    long    500
kHighBitSet     long    $8000_0000
kAllOnes        long    $ffff_ffff
kAllZeros       long    $0000_0000
kScreenBuffer   long    @screenBffr

' screen buffer 768B - 3x 256B / 1x 256B red, 1x 256B green, 1x 256B blue
                ALIGNL
screenBffr
{{
redBffr         ' byte  $f0[8]                  ' row 0
                long    $c000_000f, $f000_0051  ' row 0
                byte    $0f[8]                  ' row 1
                byte    $00[8]                  ' row 2
                byte    $00[88]
                byte    $00[8]                  ' row 14
                byte    $ff[8]                  ' row 15
redBffr2        byte    $00[8]                  ' row 16
                byte    $00[8]                  ' row 17
                byte    $ff[8]                  ' row 18
                byte    $00[88]
                byte    $00[8]                  ' row 30
                byte    $ff[8]                  ' row 31

grnBffr         byte    $00[8]                  ' row 0
                byte    $00[8]                  ' row 1
                byte    $ff[8]                  ' row 2
                byte    $00[88]
                byte    $ff[8]                  ' row 14
                byte    $00[8]                  ' row 15
grnBffr2        byte    $00[8]                  ' row 16
                byte    $ff[8]                  ' row 17
                byte    $00[8]                  ' row 18
                byte    $00[88]
                byte    $f0[8]                  ' row 30
                byte    $0f[8]                  ' row 31

bluBffr         byte    $00[8]                  ' row 0
                byte    $ff[8]                  ' row 1
                byte    $00[8]                  ' row 2
                byte    $00[88]
                byte    $00[8]                  ' row 14
                byte    $ff[8]                  ' row 15
bluBffr2        byte    $00[8]                  ' row 16
                byte    $00[8]                  ' row 17
                byte    $00[8]                  ' row 18
                byte    $ff[88]
                byte    $00[8]                  ' row 30
                byte    $00[8]                  ' row 31
}}
{{
redBffr         byte    $ff[128]                ' 1.82 Amp at 4of8 bits full screen
redBffr2        byte    $ee[128]                ' 3.46 Amp at all bits full screen
grnBffr         byte    $dd[128]                ' 0.59 Amp at 1of8 bits full screen
grnBffr2        byte    $cc[128]                ' 1.0 Amp at 2of8 bits full screen
bluBffr         byte    $bb[128]
bluBffr2        byte    $aa[128]
}}
' JumboTron frame
redBffr
                byte    $ff[8]
                byte    $00[120]
redBffr2
                byte    $00[120]
                byte    $FF[8]
grnBffr
                byte    $ff[8]
                long    $0000_0000,$0000_0001
                long    $0000_0000,$0000_0001
                long    $0000_0000,$0000_0001
                long    $0000_0000,$0000_0001
                long    $0000_0000,$0000_0001
                long    $0000_0000,$0000_0001
                long    $0000_0000,$0000_0001
                long    $0000_0000,$0000_0001
                long    $0000_0000,$0000_0001
                long    $0000_0000,$0000_0001
                long    $0000_0000,$0000_0001
                long    $0000_0000,$0000_0001
                long    $0000_0000,$0000_0001
                long    $0000_0000,$0000_0001
                long    $0000_0000,$0000_0001
grnBffr2
                long    $0000_0000,$0000_0001
                long    $0000_0000,$0000_0001
                long    $0000_0000,$0000_0001
                long    $0000_0000,$0000_0001
                long    $0000_0000,$0000_0001
                long    $0000_0000,$0000_0001
                long    $0000_0000,$0000_0001
                long    $0000_0000,$0000_0001
                long    $0000_0000,$0000_0001
                long    $0000_0000,$0000_0001
                long    $0000_0000,$0000_0001
                long    $0000_0000,$0000_0001
                long    $0000_0000,$0000_0001
                long    $0000_0000,$0000_0001
                long    $0000_0000,$0000_0001
                byte    $00[8]
bluBffr
                byte    $00[8]
                long    $8000_0000,$0000_0000
                long    $8000_0000,$0000_0000
                long    $8000_0000,$0000_0000
                long    $8000_0000,$0000_0000
                long    $8000_0000,$0000_0000
                long    $8000_0000,$0000_0000
                long    $8000_0000,$0000_0000
                long    $8000_0000,$0000_0000
                long    $8000_0000,$0000_0000
                long    $8000_0000,$0000_0000
                long    $8000_0000,$0000_0000
                long    $8000_0000,$0000_0000
                long    $8000_0000,$0000_0000
                long    $8000_0000,$0000_0000
                long    $8000_0000,$0000_0000
bluBffr2
                long    $8000_0000,$0000_0000
                long    $8000_0000,$0000_0000
                long    $8000_0000,$0000_0000
                long    $8000_0000,$0000_0000
                long    $8000_0000,$0000_0000
                long    $8000_0000,$0000_0000
                long    $8000_0000,$0000_0000
                long    $8000_0000,$0000_0000
                long    $8000_0000,$0000_0000
                long    $8000_0000,$0000_0000
                long    $8000_0000,$0000_0000
                long    $8000_0000,$0000_0000
                long    $8000_0000,$0000_0000
                long    $8000_0000,$0000_0000
                long    $8000_0000,$0000_0000
                byte    $ff[8]

endScreenBffr

' uninitialized data
'
' BUS pins
addr_bus        res     1
rgb1_bus        res     1
rgb0_bus        res     1
pCommmand       res     1
pArgument       res     1

nxtCommand      res     1
nxtArgument     res     1
pwmBffrStart    res     1
pwmFrameCt      res     1

fillBffr        res     1       ' ptr to 256 byte buffer (64 longs) -- long[32]:[RGB]1, long[32]:[RGB]2 
fillLong        res     1       ' value to write to each long
fillCount       res     1       ' [1-64] remaining count of bytes to write
fillOffset      res     1       ' [0-63] offset into fillBffr

bit_offset      res     1       ' [0-31] bit of byte within red/grn/blu register (2 registers/line)
reg_offset      res     1       ' [0-31] byte of red/grn/blu bffr[1/2]

dbgBffr         res     1
dbgCount        res     1

' variables
row_addr        res     1
row_ctr         res     1
col_addr        res     1
col_ctr         res     1

        FIT     496