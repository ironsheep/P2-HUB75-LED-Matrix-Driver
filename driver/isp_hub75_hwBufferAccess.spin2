'' =================================================================================================
''
''   File....... isp_hub75_hwBufferAccess.spin2
''   Purpose.... Describe layout of the users attached RGB LED Matrix Panel-set
''   Authors.... Stephen M Moraco
''               -- Copyright (c) 2024 Iron Sheep Productions, LLC
''               -- see below for terms of use
''   E-mail..... stephen@ironsheep.biz
''   Started.... Nov 2022
''   Updated.... 15 Jan 2024
''
'' =================================================================================================
'
'  Interface constants used to describe HUB75 panel connection and configuration

' -----------------
' User Setup Notes:
' -----------------
'   There are two areas in this file that need adjustment to the number of hub75 adapter boards you are using.
'
'   This file has ONE adapter board enabled by default.  If you are using more than one adapter board, you will
'   need to uncomment/comment out sections for each additional adapter board you wish to use.
'
'   The lines containing the text "2nd HUB75 adapter board" are lines which set up the 2nd adapter board.
'   The lines containing the text "3rd HUB75 adapter board" are lines which set up the 3rd adapter board.
'
'    There are 2 such lines in this file for each of the 2nd and 3rd adapter boards.
'     1st line activates or comments out small 17-long tables
'     2st line activates or comments out a single long pointer to the 17-long table

CON { Interface Constant Forwarding }

    ' this reduces include complexity for demo's
    HUB75_ADAPTER_1 = hwEnum.HUB75_ADAPTER_1
    HUB75_ADAPTER_2 = hwEnum.HUB75_ADAPTER_2
    HUB75_ADAPTER_3 = hwEnum.HUB75_ADAPTER_3

    DEPTH_3BIT = hwEnum.DEPTH_3BIT
    DEPTH_4BIT = hwEnum.DEPTH_4BIT
    DEPTH_5BIT = hwEnum.DEPTH_5BIT
    DEPTH_6BIT = hwEnum.DEPTH_6BIT
    DEPTH_7BIT = hwEnum.DEPTH_7BIT
    DEPTH_8BIT = hwEnum.DEPTH_8BIT

    ROT_NONE = hwEnum.ROT_NONE
    ROT_LEFT_90 = hwEnum.ROT_LEFT_90
    ROT_RIGHT_90 = hwEnum.ROT_RIGHT_90
    ROT_180 = hwEnum.ROT_180

OBJ

    hwEnum      : "isp_hub75_hwEnums"                   ' hub75 attachment, set up constants
    user        : "isp_hub75_hwPanelConfig"             ' user's panels configuration constants

DAT { Buffers and configuration values for each HUB75 adapter/chain of panels }

screenTableEnt0         ' The start of the 1st HUB75 chain descriptor table
        ' 1st HUB75 chain
'                    LONG    @hub75Buffer0, @pwmFrames0_1, @pwmFrames0_2
'-------+-----+---------+-------+---------------+-------+-----------------------+
        LONG  PLACEHOLDER_ADDRESS, PLACEHOLDER_ADDRESS, PLACEHOLDER_ADDRESS
        LONG  user.DISP0_MAX_DISPLAY_COLUMNS, user.DISP0_MAX_DISPLAY_ROWS
        LONG  user.DISP0_COLOR_DEPTH, user.DISP0_BYTES_PER_COLOR
        LONG  user.DISP0_SCRN_SIZE_IN_LONGS, user.DISP0_PWM_FRAME_SIZE_IN_BYTES, user.DISP0_ROTATION
        LONG  user.DISP0_MAX_PANEL_COLUMNS, user.DISP0_MAX_PANEL_ROWS, user.DISP0_MAX_PANELS_PER_COLUMN, user.DISP0_MAX_PANELS_PER_ROW
        LONG  PLACEHOLDER_CHIP_TYPE, PLACEHOLDER_PIN_BASE, PLACEHOLDER_ADDR_LINES
screenTableEnt0End      ' The end of the 1st HUB75 chain descriptor table

{   COMMENT-OUT THIS LINE (place tic in front of this line) if you using the 2nd HUB75 adapter board
        ' 2nd HUB75 chain
screenTableEnt1         ' The start of the 2nd HUB75 chain descriptor table
        ' 2nd HUB75 chain
        LONG    @hub75Buffer1, @pwmFrames1_1, @pwmFrames1_2
        LONG    user.DISP1_MAX_DISPLAY_COLUMNS, user.DISP1_MAX_DISPLAY_ROWS
        LONG    user.DISP1_COLOR_DEPTH, user.DISP1_BYTES_PER_COLOR
        LONG    user.DISP1_SCRN_SIZE_IN_LONGS, user.DISP1_PWM_FRAME_SIZE_IN_BYTES, user.DISP1_ROTATION
        LONG    user.DISP1_MAX_PANEL_COLUMNS, user.DISP1_MAX_PANEL_ROWS, user.DISP1_MAX_PANELS_PER_COLUMN, user.DISP1_MAX_PANELS_PER_ROW
        LONG    PLACEHOLDER_CHIP_TYPE, PLACEHOLDER_PIN_BASE, PLACEHOLDER_ADDR_LINES
'}

{   COMMENT-OUT THIS LINE (place tic in front of this line) if you using the 3rd HUB75 adapter board
        ' 3rd HUB75 chain
screenTableEnt2         ' The start of the 3rd HUB75 chain descriptor table
        LONG    @hub75Buffer2, @pwmFrames2_1, @pwmFrames2_2
        LONG    user.DISP2_MAX_DISPLAY_COLUMNS, user.DISP2_MAX_DISPLAY_ROWS
        LONG    user.DISP2_COLOR_DEPTH, user.DISP2_BYTES_PER_COLOR
        LONG    user.DISP2_SCRN_SIZE_IN_LONGS, user.DISP2_PWM_FRAME_SIZE_IN_BYTES, user.DISP2_ROTATION
        LONG    user.DISP2_MAX_PANEL_COLUMNS, user.DISP2_MAX_PANEL_ROWS, user.DISP2_MAX_PANELS_PER_COLUMN, user.DISP2_MAX_PANELS_PER_ROW
        LONG    PLACEHOLDER_CHIP_TYPE, PLACEHOLDER_PIN_BASE, PLACEHOLDER_ADDR_LINES
'}

screenTableEntEnd      ' The end of the all of the chain descriptor tables

screenTable             ' A table of addresses, pointers to each HUB75 chain descriptor table
                    LONG    @screenTableEnt0
'                    LONG    @screenTableEnt1           ' UNCOMMENT THIS LINE if you using the 2nd HUB75 adapter board
'                    LONG    @screenTableEnt2           ' UNCOMMENT THIS LINE if you using the 3rd HUB75 adapter board
screenTableEnd          ' End of the pointers table

entrySizeInBytes    LONG    (@screenTableEnt0End - @screenTableEnt0)
tableSizeInBytes    LONG    (@screenTableEntEnd - @screenTableEnt0)
numberScreens       LONG    (@screenTableEnd - @screenTable) >> 2     ' this can't be compile-time initialized

bFirstTime          LONG    TRUE                ' for debug/testing use

CON { PRIVATE internal constants }

    NOT_INITIALIZED = -1
    PLACEHOLDER_CHIP_TYPE = 0
    PLACEHOLDER_PIN_BASE = 0
    PLACEHOLDER_ADDR_LINES = 0
    PLACEHOLDER_ADDRESS = $0DF0ADDE


' offsets to each entry in our chain descriptor table
#0,  ENTR_SCRN_BUFFER_ADDR_OFST, ENTR_FRM1_BUFFER_ADDR_OFST, ENTR_FRM2_BUFFER_ADDR_OFST, ...
     ENTR_MAX_DISP_COLUMNS_OFST, ENTR_MAX_DISP_ROWS_OFST, ENTR_COLOR_DEPTH, ENTR_BYTES_PER_COLOR_OFST, ...
     ENTR_SCRN_SIZE_IN_LONGS_OFST, ENTR_FRM_SIZE_IN_BYTES_OFST, ENTR_ROTATION_OFST, ...
     ENTR_PANEL_COLUMNS_OFST, ENTR_PANEL_ROWS_OFST, ENTR_PANELS_PER_COLUMN_OFST, ENTR_PANELS_PER_ROW_OFST, ...
     ENTR_CHIP_TYPE_OFST, ENTR_HUB75_PIN_BASE_OFST, ENTR_HPANEL_ADDR_LINES_OFST

PUB null()
'' This is not a top level object

PUB configure(eHub75Chain, ePinBase, eChipType, eAddrLines) | pEntry, nChainIdx, bValidPins
'' Record the base-pin, chip type, number of address lines for the nChainIdx HUB75 adapter

    nChainIdx := indexForHub75ChainId(eHub75Chain)    ' 10, 20, 30
    pEntry := ptrTableEntry(nChainIdx)   ' get ptr to table entry
    bValidPins := TRUE
    case ePinBase
        hwEnum.PINS_P0_P15:
        hwEnum.PINS_P16_P31:
        hwEnum.PINS_P32_P47:
        hwEnum.PINS_P48_P63:
            bValidPins := FALSE ' hub75 board can't work here
            debug("HUB75: configure() Can't use PINS 48-63: [isp_hub75_hwBufferAccess.spin2] Aborted!")
        other:
            bValidPins := FALSE ' this is not a ligit base number
            debug("HUB75: configure() Invalid PinBase/PinGroup specfied: [isp_hub75_hwBufferAccess.spin2] Aborted!")

    if not bValidPins
        abort   ' we can't continue given this error
    else
        LONG[pEntry][ENTR_CHIP_TYPE_OFST] := eChipType
        LONG[pEntry][ENTR_HUB75_PIN_BASE_OFST] := ePinBase
        LONG[pEntry][ENTR_HPANEL_ADDR_LINES_OFST] := eAddrLines
        if bFirstTime
            'dbgMemDump(@"PTRs", @screenTable, numberScreens * 4)
            'dbgMemDump(@"Entry 0", @screenTableEnt0, entrySizeInBytes)
            bFirstTime := FALSE
        debug("HUB75: configure() idx=", udec_(nChainIdx), udec(nChainIdx), udec(ePinBase), udec(eAddrLines))


PUB setBufferPointers(nChainIdx, pScrnBuffer, pPwmFrameSet1, pPwmFrameSet2) | pEntry, longsInEntry

'' forward the buffer pointers to the underlying buffer access routines
''
'' @param nChainIdx - the index of the desired chain of panels (hub75 adapter)
'' @param pScrnBuffer - address of screen Buffer (2-3 bytes per pixel)
'' @param pPwmFrameSet1 - address of PWM Frame-Set 1 (4 bits per pixel * color depth)
'' @param pPwmFrameSet2 - address of PWM Frame-Set 2 (4 bits per pixel * color depth)

    pEntry := ptrTableEntry(nChainIdx)   ' get ptr to table entry
    ' and record the absolute-address of the buffers in HUB RAM
    LONG[pEntry][ENTR_SCRN_BUFFER_ADDR_OFST] := pScrnBuffer
    LONG[pEntry][ENTR_FRM1_BUFFER_ADDR_OFST] := pPwmFrameSet1
    LONG[pEntry][ENTR_FRM2_BUFFER_ADDR_OFST] := pPwmFrameSet2
    debug("HUB75: setBufferPointers() idx[", udec_(nChainIdx), "] ", uhex_long(pScrnBuffer, pPwmFrameSet1, pPwmFrameSet2))
    longsInEntry := tableSizeInBytes / 4
    debug("HUB75: chain table size=", udec_(tableSizeInBytes), " entries [0-2]", uhex_long_array(@screenTableEnt0, 3))
    debug("HUB75: chain table values[3-13]: ", udec_long_array(@LONG[@screenTableEnt0][3], longsInEntry - 3 ))


PUB maxDisplayColumns(nChainIdx) : nMaxColumns | pEntry
'' Return the number of pixels in a horizontal display row for the nChainIdx HUB75 adapter
''
'' @param nChainIdx - the index of the desired chain
'' @returns nMaxColumns - the number of pixels horizontally in display

' Local Variables:
' @local pEntry - temp var pointing to table entry for chain

    pEntry := ptrTableEntry(nChainIdx)   ' get ptr to table entry
    nMaxColumns := LONG[pEntry][ENTR_MAX_DISP_COLUMNS_OFST]


PUB displaySizeInPixels(nChainIdx) : nMaxRows, nMaxColumns | pEntry
'' Return the number of pixels in a display row and column for the nChainIdx HUB75 adapter
''
'' @param nChainIdx - the index of the desired chain
'' @returns nMaxRows - the number of pixels vertically in display
'' @returns nMaxColumns - the number of pixels horizontally in display

' Local Variables:
' @local pEntry - temp var pointing to table entry for chain

    pEntry := ptrTableEntry(nChainIdx)   ' get ptr to table entry
    nMaxRows := LONG[pEntry][ENTR_MAX_DISP_ROWS_OFST]
    nMaxColumns := LONG[pEntry][ENTR_MAX_DISP_COLUMNS_OFST]


PUB displaySizeInPanels(nChainIdx) : nPanelsPerColumn, nPanelsPerRow  | pEntry

'' Return the number of panels in each row and column for the nChainIdx HUB75 adapter
''
'' @param nChainIdx - the index of the desired chain
'' @returns nPanelsPerColumn - the number of panels vertically in display
'' @returns nPanelsPerRow - the number of panels horizontally in display

' Local Variables:
' @local pEntry - temp var pointing to table entry for chain

    pEntry := ptrTableEntry(nChainIdx)   ' get ptr to table entry
    nPanelsPerColumn := LONG[pEntry][ENTR_PANELS_PER_COLUMN_OFST]
    nPanelsPerRow := LONG[pEntry][ENTR_PANELS_PER_ROW_OFST]

PUB colorDepth(nChainIdx) : nDepthInBits | pEntry
'' Return the number of bits for a color (red, green, or blue) [3-8 bits] for the nChainIdx HUB75 adapter
    pEntry := ptrTableEntry(nChainIdx)   ' get ptr to table entry
    nDepthInBits := LONG[pEntry][ENTR_COLOR_DEPTH]

PUB bytesPerColor(nChainIdx) : nBytes | pEntry
'' Return the number of bytes needed to store a pixel color (r+b+g) for the nChainIdx HUB75 adapter
    pEntry := ptrTableEntry(nChainIdx)   ' get ptr to table entry
    nBytes := LONG[pEntry][ENTR_BYTES_PER_COLOR_OFST]

PUB displaySizeInLongs(nChainIdx) : nLongs | pEntry
'' Return the number of LONGs needed to store an entire display image for the nChainIdx HUB75 adapter
    pEntry := ptrTableEntry(nChainIdx)   ' get ptr to table entry
    nLongs := LONG[pEntry][ENTR_SCRN_SIZE_IN_LONGS_OFST]

PUB pwmFrameSizeInBytes(nChainIdx) : nBytes | pEntry
'' Return the number of LONGs needed to store a single PWM frame of a display image for the nChainIdx HUB75 adapter
    pEntry := ptrTableEntry(nChainIdx)   ' get ptr to table entry
    nBytes := LONG[pEntry][ENTR_FRM_SIZE_IN_BYTES_OFST]

PUB pwmFrameSizeInLongs(nChainIdx) : nLongs | nBytes
'' Return the number of LONGs needed to store a single PWM frame of a display image for the nChainIdx HUB75 adapter
    nBytes := pwmFrameSizeInBytes(nChainIdx)   ' count of bytes
    nLongs := (nBytes + 3) / 4

PUB panelRotation(nChainIdx) : ePanelRotation | pEntry
'' Return the enum indicating desire rotation
    pEntry := ptrTableEntry(nChainIdx)   ' get ptr to table entry
    ePanelRotation := LONG[pEntry][ENTR_ROTATION_OFST]

PUB panelSizeInPixels(nChainIdx) : nPanelRows, nPanelColumns | pEntry
'' Return the number of pixels in a single panel row of pixels for the nChainIdx HUB75 adapter
    pEntry := ptrTableEntry(nChainIdx)   ' get ptr to table entry
    nPanelColumns := LONG[pEntry][ENTR_PANEL_COLUMNS_OFST]
    nPanelRows := LONG[pEntry][ENTR_PANEL_ROWS_OFST]

PUB displayBufferAddress(nChainIdx) : pDisplayBuffer | pEntry
'' Return the address of the memory buffer associated with the nChainIdx HUB75 adapter
    pEntry := ptrTableEntry(nChainIdx)   ' get ptr to table entry
    pDisplayBuffer := LONG[pEntry][ENTR_SCRN_BUFFER_ADDR_OFST]

PUB pwmFrame1BufferAddress(nChainIdx) : pPwmFrm1Buffer | pEntry
'' Return the address of the 1st PWM Frame buffer associated with the nChainIdx HUB75 adapter
    pEntry := ptrTableEntry(nChainIdx)   ' get ptr to table entry
    pPwmFrm1Buffer := LONG[pEntry][ENTR_FRM1_BUFFER_ADDR_OFST]

PUB pwmFrame2BufferAddress(nChainIdx) : pPwmFrm2Buffer | pEntry
'' Return the address of the 2nd PWM Frame buffer associated with the nChainIdx HUB75 adapter
    pEntry := ptrTableEntry(nChainIdx)   ' get ptr to table entry
    pPwmFrm2Buffer := LONG[pEntry][ENTR_FRM2_BUFFER_ADDR_OFST]

PUB chipType(nChainIdx) : nChipType | pEntry
'' Return the chip-type for the nChainIdx HUB75 adapter
    pEntry := ptrTableEntry(nChainIdx)   ' get ptr to table entry
    nChipType := LONG[pEntry][ENTR_CHIP_TYPE_OFST]

PUB pinBase(nChainIdx) : nPinBase | pEntry
'' Return the basePin for the nChainIdx HUB75 adapter
    pEntry := ptrTableEntry(nChainIdx)   ' get ptr to table entry
    nPinBase := LONG[pEntry][ENTR_HUB75_PIN_BASE_OFST]

PUB addressLines(nChainIdx) : nAddrLines | pEntry
'' Return the number of HUB75 address lines for the nChainIdx HUB75 adapter
    pEntry := ptrTableEntry(nChainIdx)   ' get ptr to table entry
    nAddrLines := LONG[pEntry][ENTR_HPANEL_ADDR_LINES_OFST]

PUB maxPanels(nChainIdx) : nMaxPanels | pEntry, panelsInRow, panelsInColumn
'' Return the total number of panels connected to the nChainIdx HUB75 adapter
''
'' @param nChainIdx - the index of the desired chain
'' @returns nMaxPanels - total number of panels connected to the nChainIdx HUB75 adapter

' Local Variables:
' @local pEntry - temp var pointing to table entry for chain
' @local panelsInRow - temp var for number of panels in a row
' @local panelsInColumn - temp var for number of panels in a column

    panelsInColumn, panelsInRow := displaySizeInPanels(nChainIdx)
    nMaxPanels := panelsInRow * panelsInColumn

PUB zeroFillBuffer(nChainIdx) | pBffr, nBffrLen
'' Zero fill the display buffer associated with the nChainIdx HUB75 adapter
    nBffrLen := displaySizeInLongs(nChainIdx)
    pBffr := displayBufferAddress(nChainIdx)
    longfill(pBffr, 0, nBffrLen)

PUB indexForHub75ChainId(eHub75Chain) : nChainIdx | bValidChain
'' Return the index into our table for a given HUB75 Adapter
    nChainIdx := 0  ' default to first or only panel
    bValidChain := TRUE
    case eHub75Chain
        HUB75_ADAPTER_1:
        HUB75_ADAPTER_2:
        HUB75_ADAPTER_3:
        other:
            bValidChain := FALSE
            debug("ERROR: unknown chain id (", udec_(eHub75Chain), ") must be [10, 20, or 30]")
            abort
    if bValidChain
        nChainIdx := (eHub75Chain / 10) - 1  ' 10, 20, 30 -> 1,2,3 -> 0,1,2

PUB pwmFrameCount(nChainIdx) : nbrPwmFrames | nColorDepth
'' Return the number of pwm frames to display for selected bit depth
    nColorDepth := colorDepth(nChainIdx)
    case nColorDepth
        hwEnum.DEPTH_3BIT:
            nbrPwmFrames := 7
        hwEnum.DEPTH_4BIT:
            nbrPwmFrames := 15
        hwEnum.DEPTH_5BIT:
            nbrPwmFrames := 31
        hwEnum.DEPTH_6BIT:
            nbrPwmFrames := 63
        hwEnum.DEPTH_7BIT:
            nbrPwmFrames := 127
        hwEnum.DEPTH_8BIT:
            nbrPwmFrames := 255
        other:
            nbrPwmFrames := 15  ' default to DEPTH_4BIT if set badly

PUB indexToPanel(nChainIdx, nPanelRow, nPanelCol) : nPanelIndex | nBffrR, nBffrC, rowsPerPnl, colsPerPnl, panelsPerRow, panelsPerColumn
'' Return the index of the panel within entire display at the specified panel-row and panel-column
''
'' @param nChainIdx - the index of the desired chain
'' @param nPanelRow - index of specified panel in row
'' @param nPanelCol - index of specified panel in column
'' @returns nPanelIndex - index of panel within entire display

' Local Variables:
' @local nBffrR -
' @local nBffrC -
' @local rowsPerPnl -
' @local colsPerPnl -
' @local panelsPerRow -
' @local panelsPerColumn -

    rowsPerPnl, colsPerPnl := panelSizeInPixels(nChainIdx)
    panelsPerRow, panelsPerColumn := displaySizeInPanels(nChainIdx)
    nBffrR := 0 #> nPanelRow <# rowsPerPnl - 1
    nBffrC := 0 #> nPanelCol <# colsPerPnl - 1
    nPanelIndex := (nBffrR * panelsPerRow) + nBffrC

PUB offsetToPanel(nChainIdx, nPanelIndex) : offsetPixelRows, offsetPixelColumns | gridRow, gridColumn, nMaxPanels, panelIndex, rowsPerPnl, colsPerPnl, pnlsPerRow, pnlsPerCol
'' Return x,y offset to specified panel from top-left corner of display
''
'' @param nChainIdx - the index of the desired chain
'' @param nPanelIndex - index of panel within entire display
'' @returns offsetPixelRows - vertical offset to top-left pixel of specified panel from top-left corner of display
'' @returns offsetPixelColumns - horizontal offset to top-left pixel of specified panel from top-left corner of display

' Local Variables:
' @local gridRow -
' @local gridColumn -
' @local nMaxPanels -
' @local panelIndex -
' @local rowsPerPnl -
' @local colsPerPnl -
' @local pnlsPerRow -
' @local pnlsPerCol -

    offsetPixelRows := offsetPixelColumns := 0
    nMaxPanels := maxPanels(nChainIdx)
    rowsPerPnl, colsPerPnl := panelSizeInPixels(nChainIdx)
    pnlsPerCol, pnlsPerRow := displaySizeInPanels(nChainIdx)
    if nMaxPanels > 0
        panelIndex :=  0 #> nPanelIndex <# nMaxPanels - 1
        if nPanelIndex <> panelIndex
            debug("* Warning invalid nPanelIndex (", udec_(nPanelIndex), ") for display! of ", udec_(nMaxPanels), " panels")

        if pnlsPerRow == 1 and pnlsPerCol == 1
            ' we have a one panel, no offset
        elseif pnlsPerRow == 1
            ' we have a column of panels
            offsetPixelRows := panelIndex * rowsPerPnl
        elseif pnlsPerCol == 1
            ' we have a row of panels
            offsetPixelColumns := panelIndex * colsPerPnl
        else
            ' we have a grid of panels: MAX_PANELS_PER_ROW x MAX_PANELS_PER_COLUMN
            gridRow := panelIndex / pnlsPerRow
            gridColumn := panelIndex // pnlsPerRow
            offsetPixelRows := gridRow * rowsPerPnl
            offsetPixelColumns := gridColumn * colsPerPnl

    return offsetPixelRows, offsetPixelColumns

PUB getDriverFlags(nChainIdx) : desiredFlags, eChipType
'' Return flags describing the compiled driver configuration
    desiredFlags := eChipType := chipType(nChainIdx)
    if eChipType == hwEnum.CHIP_FM6126A
        desiredFlags := hwEnum.CHIP_MANUAL_SPEC | hwEnum.LAT_POSN_OVERLAP | hwEnum.LAT_STYLE_OFFSET | hwEnum.INIT_PANEL_REQUIRED
    elseif eChipType == hwEnum.CHIP_GS6238S
        desiredFlags := hwEnum.CHIP_MANUAL_SPEC | hwEnum.LAT_POSN_OVERLAP | hwEnum.LAT_STYLE_OFFSET | hwEnum.GB_SWAP
    elseif eChipType == hwEnum.CHIP_DP5125D
        desiredFlags := hwEnum.CHIP_MANUAL_SPEC | hwEnum.LAT_POSN_OVERLAP | hwEnum.LAT_STYLE_OFFSET | hwEnum.SCAN_4
    elseif eChipType == hwEnum.CHIP_MBI5124GP
        desiredFlags := hwEnum.CHIP_MANUAL_SPEC | hwEnum.CHIP_UNK_LAT_END_ENCL | hwEnum.SCAN_4 | hwEnum.INIT_PANEL_REQUIRED
    elseif eChipType == hwEnum.CHIP_FM6124 or eChipType == hwEnum.CHIP_UNK_LAT_END_ENCL
        if eChipType == hwEnum.CHIP_FM6124
            desiredFlags := hwEnum.CHIP_MANUAL_SPEC
    elseif eChipType == hwEnum.CHIP_ICN2037 or eChipType == hwEnum.CHIP_ICN2038S or eChipType == hwEnum.CHIP_UNK_LAT_END_ENCL_SLO_CLK
        if eChipType == hwEnum.CHIP_ICN2037
            desiredFlags := hwEnum.CHIP_MANUAL_SPEC | hwEnum.CLK_WIDE_PULSE | hwEnum.RB_SWAP
        elseif eChipType == hwEnum.CHIP_ICN2038S
            desiredFlags := hwEnum.CHIP_MANUAL_SPEC | hwEnum.CLK_WIDE_PULSE | hwEnum.SCAN_4
    elseif eChipType & $ff <> hwEnum.CHIP_MANUAL_SPEC
        ' report ERROR and exit
        debug("- have unknown CHIP ", ubin_word(desiredFlags))
        abort

PUB dbgMemDump(pMessage, pBytes, lenBytes) | bytBffr, colIdx, rowIdx, maxCol, maxRow, dispLen
'' Dump bytes in hex format to debug() terminal
    debug("`temp '", zstr_(pMessage), ": bffr=", uhex_long_(pBytes), "(", udec_(lenBytes), ")' 13")
    maxCol := lenBytes >= 16 ? 15 : lenBytes
    maxRow := (lenBytes / 16)
    if maxRow * 16 < lenBytes
        maxRow++
    if maxRow == 0
        maxRow := 1

    bytBffr := pBytes
    waitus(35)
    'returns
    dispLen := 0
    repeat rowIdx from 1 to maxRow
        if rowIdx < 10
            debug("`temp ' '")  ' space
        debug("`temp '  ", uhex_long_(bytBffr), ": '")
        repeat colIdx from 0 to maxCol
            debug("`temp '", uhex_byte_(byte[bytBffr+colIdx]), " '")
            dispLen++
            if dispLen >= lenBytes
                quit
            if colIdx == 7
                debug("`temp ' '")      ' space

        bytBffr += 16
        debug("`temp 13")               ' newline
        waitus(85)  ' 50 too short, 70 less issue, 75 better,
    waitms(2)

PRI ptrTableEntry(nChainIdx) : pEntry | validScreenIdx
    'debug("HUB75dbg: ", udec(nChainIdx), udec(numberScreens), udec(tableSizeInBytes), udec(entrySizeInBytes))
    validScreenIdx := 0 #> nChainIdx <# numberScreens - 1
    if nChainIdx <> validScreenIdx
        debug("HUB75: not enough HUB75 buffers allocated: [isp_hub75_hwBufferAccess.spin2]")
        abort

    pEntry := @@LONG[@screenTable][validScreenIdx] ' get ptr to table entry

CON { license }

{{

 -------------------------------------------------------------------------------------------------
  MIT License

  Copyright (c) 2024 Iron Sheep Productions, LLC

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
 =================================================================================================

}}
