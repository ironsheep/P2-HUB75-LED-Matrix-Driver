'' =================================================================================================
''
''   File....... isp_hub75_panel.spin2
''   Purpose.... Manage the HUB75 panel content
''   Authors.... Stephen M Moraco
''               -- Copyright (c) 2020 Iron Sheep Productions, LLC
''               -- see below for terms of use
''   E-mail..... stephen@ironsheep.biz
''   Started.... Oct 2020
''   Updated.... 01 Dec 2020
''
''  This object provides 24bit screen buffer to PWM buffers support
'' =================================================================================================


CON { I/O PINs }

' None

OBJ

    screen      : "isp_hub75_screenAccess"
    matrix      : "isp_hub75_rgb3bit"
    'matrix      : "isp_hub75_rgb3bit-LE"
    color       : "isp_hub75_color"

VAR { driver instance variables }

    long    cog
    long    bus           ' ram/flash
    long    pwmFrames1[screen.MAX_PWM_FRAMES * screen.MAX_PWM_FRAME_SIZE_IN_LONGS]
    long    pwmFrames2[screen.MAX_PWM_FRAMES * screen.MAX_PWM_FRAME_SIZE_IN_LONGS]
    byte    usePwmFrameset1

' ----------------------------------------------------------

PUB start() : ok
    '' Start the backend pasm2 driver for the matrix

    debug("- PNL: Start Matrix COG")
    ok := cog := matrix.start()   ' send buffer to driver
    if ok == -1
        debug("- PNL: underlying drivers failed!")
        abort

    usePwmFrameset1 := TRUE

    clearPwmFrameBuffer()  ' clear PWM frames  and get pointer to buffer
    clearPwmFrameBuffer()  ' this clears 2nd frame-set, too

PUB stop()
    '' Stop the pasm2 backend driver
    if cog
        matrix.stop()
        cog := 0

PRI waits(nSeconds)
    repeat nSeconds
        waitms(1000)    ' 1 seconds

PUB fillPanel(threeBitColor)
    '' Fill screen but without PWM (for testing underlying driver)
    matrix.fillPanel(threeBitColor)

PUB convertScreen2PWM_14(p24bitScreen, bSwapRB) | pPwmFrameSet, nFrameOffset, nFrameIdx, nFrameCtr, pPwmFrame
    '' Load a 24-bit-color image into PWM frame buffers at 8s (4 scan-lines at a time) [PASM]
    ' scan memory, write PWM bytes twice
    debug("- PNL:cs2pwm(): scn ", uhex_long(p24bitScreen), uhex_long(bSwapRB))

    ' -------------------------------------------------------------------------
    ' NOTES for panel P4-1921-8S-V2.0 - 1/8 scan
    '  two full 64px lines are emmitted for wach row, or 128px per each of 8 rows
    '  the top 16 rows are fed by RGB1, while the bottom 16 rows are fed by RGB2
    '
    '  64px lines do NOT span multiple rows! This means we can do a simple row-
    '  number translation when mapping our PWM buffers to how the panel will display
    '  the pixel values.
    '
    '  The mapping is as follows:
    '    ----- TOP ------                    ----- BOTTOM -----
    '  Row 0 is placed in PWM bffr Row 1    Row 16 into pwm Row 17
    '      1   ->   3                           17   ->   19
    '      2   ->   5                           18   ->   21
    '      3   ->   7                           19   ->   23
    '      4   ->   9                           20   ->   25
    '      5   ->  11                           21   ->   27
    '      6   ->  13                           22   ->   29
    '      7   ->  15                           23   ->   31
    '     ------------                          ------------
    '      8   ->   0                           24   ->   16
    '      9   ->   2                           25   ->   18
    '     10   ->   4                           26   ->   20
    '     11   ->   6                           27   ->   22
    '     12   ->   8                           28   ->   24
    '     13   ->  10                           29   ->   26
    '     14   ->  12                           30   ->   28
    '     15   ->  14                           31   ->   30
    ' -------------------------------------------------------------------------
    ' this routine does not prestore all the transformed bytes
    '  instead it scans each pixel at RC of the screen size
    '  it then places either RGB1 into the each pwm frames' buffer
    '   or if we are addressing the BOTTOM then it reads RGB1 value
    '   from the pwm frames' buffer and or's in the RGB2 values
    '
    '  THIS means that each screen buffer byte is read once while each
    '    PWM buffer byte is written twice.
    '  Anyway, the math to calculate the target pixel byte in the pwm buffer
    '   is:
    ' -------------------------------------------------------------------------
    '  The targetRow math of:
    '    rows  0 -  7: targetRow = (row * 2) + 1
    '    rows  8 - 15: targetRow = (row mod 8) * 2
    '    rows 16 - 24: targetRow = ((row - 16) * 2) + 17
    '    rows 24 - 31: targetRow = (row - 24) * 2) + 16
    ' -------------------------------------------------------------------------

    ' init ptrs
    pPwmFrameSet := getActivePwmBuffer()

    org
            ' init variables
                    ' setup for red/blue flip if needed
                    or      bSwapRB, bSwapRB   wz
    if_nz           mov     redBitRGB1Value, #$04
    if_nz           mov     blueBitRGB1Value, #$01
    if_z            mov     redBitRGB1Value, #$01
    if_z            mov     blueBitRGB1Value, #$04
    if_nz           mov     redBitRGB2Value, #$20
    if_nz           mov     blueBitRGB2Value, #$08
    if_z            mov     redBitRGB2Value, #$08
    if_z            mov     blueBitRGB2Value, #$20
for8SScreen
            ' for all pixels of the screen buffer
                'repeat nPhysLineIdx from 0 to screen.MAX_PHYSICAL_ROWS - 1             ' [0-31]
                    mov     nPhysLineIdx, #0
                    mov     nPhysLineCtr, #screen.MAX_PHYSICAL_ROWS
                'repeat nColumnIdx from 0 to screen.MAX_PHYSICAL_COLUMNS - 1       ' [0-63]
next8SLine
                    mov     nColumnIdx, #0
                    mov     nColumnCtr, #screen.MAX_PHYSICAL_COLUMNS
next8SColumn
                ' calc nRGBColorOfst: offset into screen buffer
                'nRGBColorOfst := ((nPhysLineIdx * screen.MAX_PHYSICAL_COLUMNS) + nColumnIdx) * screen.DISPLAY_BYTES_PER_COLOR
                    mov     nRGBColorOfst, nPhysLineIdx
                    mul     nRGBColorOfst, #screen.MAX_PHYSICAL_COLUMNS
                    add     nRGBColorOfst, nColumnIdx
                    mul     nRGBColorOfst, #screen.DISPLAY_BYTES_PER_COLOR
                ' calc nPwmRGB12ByteIdx: offset into PWM buffer
                    mov     nTargLineIdx, nPhysLineIdx      ' start with phys row number
                    '  if low-half rows of panel...
                    cmp     nPhysLineIdx, oneHalfLineCt     wc
    if_nc           jmp     #bottom8SRows
top8SRows           ' determine calcs to use for top half of panel - Rows [0-15]
                    ' if nPhysLineIdx < one4thLineCt...
                    cmp     nPhysLineIdx, one4thLineCt      wc
                    ' CY=1: nTargLineIdx := (nPhysLineIdx * 2) + 1 - rows  [0-7]
    if_c            shl     nTargLineIdx, #1      ' mult by 2
    if_c            add     nTargLineIdx, #1      ' add 1
                    ' CY=0: nTargLineIdx := (nPhysLineIdx // one4thLineCt) * 2 - Rows [8-15]
    if_nc           mov     maskQtrRowsModulus, one4thLineCt    ' get our pwr-of-2 row count
    if_nc           sub     maskQtrRowsModulus, #1              ' subtract 1 to get mask
    if_nc           and     nTargLineIdx, maskQtrRowsModulus    ' remove all upper bits (eff. modulus)
    if_nc           shl     nTargLineIdx, #1                    ' mult by 2
                    jmp     #targ8SCalcsDone
bottom8SRows        ' determine calcs to use for bottom half of panel - Rows [16-31]
                    ' if nPhysLineIdx < three4thsLineCt
                    cmp     nPhysLineIdx, three4thsLineCt      wc
                    ' CY=1: nTargLineIdx := ((nPhysLineIdx - oneHalfLineCt) * 2) + oneHalfLineCt + 1 - Rows [16-23]
    if_c            sub     nTargLineIdx, oneHalfLineCt    ' minus oneHalfLineCt
    if_c            shl     nTargLineIdx, #1                  ' mult by 2
    if_c            add     nTargLineIdx, oneHalfLineCt    ' add oneHalfLineCt
    if_c            add     nTargLineIdx, #1                  ' add 1
                    ' CY=0: nTargLineIdx := ((nPhysLineIdx - three4thsLineCt) + oneHalfLineCt) * 2 - Rows  [24-31]
    if_nc           sub     nTargLineIdx, three4thsLineCt  ' minus three4thsLineCt
    if_nc           add     nTargLineIdx, oneHalfLineCt    ' add oneHalfLineCt
    if_nc           shl     nTargLineIdx, #1                  ' mult by 2
targ8SCalcsDone
                    ' nPwmRGB12ByteIdx := (nTargLineIdx * screen.MAX_PHYSICAL_COLUMNS) + nColumnIdx
                    mov     nPwmRGB12ByteIdx, nTargLineIdx
                    mul     nPwmRGB12ByteIdx, #screen.MAX_PHYSICAL_COLUMNS
                    add     nPwmRGB12ByteIdx, nColumnIdx
                    ' bIsBottomHalf := (nTargLineIdx > oneHalfLineCt - 1) ? TRUE : FALSE
                    cmp     nTargLineIdx, oneHalfLineCt    wc
    if_nc           mov     bIsBottomHalf, allOnes               ' TRUE if row 16-31
    if_c            mov     bIsBottomHalf, #0                    ' FALSE if row 0-15
                    ' ----------------------------
                    '   DEBUG DEBUG DEBUG
                    ' if nColumnIdx < 2 or nColumnIdx > 61
                    cmp     nColumnIdx, #2    wc
    if_c            jmp     #show8SDebug                          ' show debug
                    cmp     nColumnIdx, #61   wc
    if_c            jmp     #no8SDebug                            ' don't show debug
show8SDebug
                    debug("- PNL:cs2pwm(): physR ", udec_long_(nPhysLineIdx), ", targR ", udec_long_(nTargLineIdx), ", col ", udec_long_(nColumnIdx), ", scnIdx ", udec_long_(nRGBColorOfst), ", pwmIdx ", udec_long_(nPwmRGB12ByteIdx))
no8SDebug
                    '   DEBUG DEBUG DEBUG
                    ' ----------------------------
                ' locate and load color for scanline
                    ' now create a column/pixel index for this offset
                    ' pRGBPixAddr := @byte[p24bitScreen][nRGBColorOfst]    ' add in offset to 24-bit color
                    ' FIXME: UNDONE - convert this to just add 1 to pointer each loop?!!!
                    mov     pRGBPixAddr, p24bitScreen
                    add     pRGBPixAddr, nRGBColorOfst
                    rdlong  colorValue24bit, pRGBPixAddr
                    ' red := byte[pRGBPixAddr][0]
                    getbyte currPwmBits, colorValue24bit,#0
                    call    #cvt8SCurr2pwm
                    mov     redPwmBits, currPwmBits
                    ' green := byte[pRGBPixAddr][1]
                    getbyte currPwmBits, colorValue24bit,#1
                    call    #cvt8SCurr2pwm
                    mov     greenPwmBits, currPwmBits
                    ' blue := byte[pRGBPixAddr][2]
                    getbyte currPwmBits, colorValue24bit,#2
                    call    #cvt8SCurr2pwm
                    mov     bluePwmBits, currPwmBits

                    ' write color information to our PWM buffers
                    ' expand PWM-Bit-width bits into N pwm frames of 3-bit pixels two pixels/byte

                    ' for ea. bit do...
                    ' repeat currPwmBitNumber from 0 to screen.MAX_PWM_FRAMES - 1
                    mov     currPwmBitNumber, #0                           ' start with bit0 of [0-MAX_PWM_FRAMES - 1]
                    mov     pwmBitCtr, #screen.MAX_PWM_FRAMES        ' MAX PWM FRAME bits to scan in LONG
next8SPwmFrame
                    ' calculate pointer to frame for this bit #
                    '   nFrameOffset := frameIdx * screen.MAX_PWM_FRAME_SIZE_IN_LONGS ' 256 longs in each frame
                    '   pPwmFrame := @long[getActivePwmBuffer()][nFrameOffset]
                    mov     pPwmFrame, currPwmBitNumber
                    mul     pPwmFrame, ##screen.MAX_PWM_FRAME_SIZE_IN_BYTES
                    add     pPwmFrame, pPwmFrameSet
                    ' calc address of byte in pwm frame for this nPwmRGB12ByteIdx
                    mov     pPwmFrameByte, nPwmRGB12ByteIdx
                    add     pPwmFrameByte, pPwmFrame

                    ' build top RGB1 or bottom RGB2 bits to be stored in pwm byte
                    ' if not bIsBottomHalf
                    or      bIsBottomHalf,bIsBottomHalf     wz
    if_nz           jmp     #bottom8SHalf
top8SHalf
                    ' bitsBGR := 0
                    mov     bitsBGR, #0                    ' clear all bits
                    ' set our RGB1 bits
                    '     bitsBGR |= (rPwm & currBitMask) > 0 ? 1 : 0
                    '     bitsBGR |= (gPwm & currBitMask) > 0 ? 2 : 0
                    '     bitsBGR |= (bPwm & currBitMask) > 0 ? 4 : 0
                    testb   redPwmBits, currPwmBitNumber     wc
        if_c        or      bitsBGR, redBitRGB1Value
                    testb   greenPwmBits, currPwmBitNumber   wc
        if_c        or      bitsBGR, greenBitRGB1Value
                    testb   bluePwmBits, currPwmBitNumber    wc
        if_c        or      bitsBGR, blueBitRGB1Value
                    jmp     #write8SPwmByte
bottom8SHalf
                '    bitsBGR := byte[pPwmFrame][nPwmRGB12ByteIdx]
                    rdbyte  bitsBGR, pPwmFrameByte       ' load current value
                    and     bitsBGR, maskOnlyRGB1bits   ' clear all bits except RGB1 value
                    ' set our RGB2 bits
                    '    bitsBGR |= (rPwm & currBitMask) > 0 ? 8 : 0
                    '    bitsBGR |= (gPwm & currBitMask) > 0 ? $10 : 0
                    '    bitsBGR |= (bPwm & currBitMask) > 0 ? $20 : 0
                    testb   redPwmBits, currPwmBitNumber     wc
        if_c        or      bitsBGR, redBitRGB2Value
                    testb   greenPwmBits, currPwmBitNumber   wc
        if_c        or      bitsBGR, greenBitRGB2Value
                    testb   bluePwmBits, currPwmBitNumber    wc
        if_c        or      bitsBGR, blueBitRGB2Value
write8SPwmByte
                ' write RGB1, RGB2 value to byte
                'byte[pPwmFrame][nPwmRGB12ByteIdx] := bitsBGR
                    wrbyte  bitsBGR, pPwmFrameByte       ' load current value
                    ' this one done, if not all 8 bits done, go do next
                    add     currPwmBitNumber, #1
                    djnz    pwmBitCtr, #next8SPwmFrame

                    ' count this column, go do next column if not yet done
                    add     nColumnIdx, #1
                    djnz    nColumnCtr, #next8SColumn
                    ' count this row, go do next row if not yet done
                    add     nPhysLineIdx, #1
                    djnz    nPhysLineCtr, #next8SLine
                    jmp     #doneS8

' currPwmBits := cvtCurr2pwm(currPwmBits)   ' NOTE wipes tempByte
cvt8SCurr2pwm
                    or      currPwmBits, currPwmBits    wz  ' special case: if zero return all 0 bits
        if_z        ret
                    sub     currPwmBits, #1                 ' subtract 1 from our count
                    bmask   currPwmBits, currPwmBits        ' convert bit count into string of bits
                    ret
doneS8

' the following initialized values are simply copied into PASM area before routine is run
pPwmFramePtrSet     long    0[screen.MAX_PWM_FRAMES]
nPixelCtr           long    (screen.MAX_PHYSICAL_ROWS * screen.MAX_PHYSICAL_COLUMNS) / 2
nPhysLineIdx        long    0
nPhysLineCtr        long    0
nColumnIdx          long    0
nColumnCtr          long    0
nTargLineIdx        long    0
nPwmRGB12ByteIdx    long    0
bIsBottomHalf       long    0
nRGBColorOfst       long    0
maskQtrRowsModulus  long    0
pRGBPixAddr         long    0
redBitRGB1Value     long    $01
greenBitRGB1Value   long    $02
blueBitRGB1Value    long    $04
redBitRGB2Value     long    $08
greenBitRGB2Value   long    $10
blueBitRGB2Value    long    $20
maskOnlyRGB1bits    long    $07
midDisplayRow       long    0
redPwmBits          long    0
greenPwmBits        long    0
bluePwmBits         long    0
pPwmFrameByt        long    0
colorValue24bit     long    0
colorValueTop       long    0
colorValueBot       long    0
colorMask           long    0
pwmBitCtr           long    0
currPwmBitNumber    long    0
bitsBGR             long    0
rowIndexHalfPanel   long    0
pPwmFrameByte       long    0
currPwmColorBits    long    0
currPwmBits         long    0
tempByte            long    0
allOnes             long    $ffffffff
one4thLineCt        long    (screen.MAX_PHYSICAL_ROWS / 4)
oneHalfLineCt       long    (screen.MAX_PHYSICAL_ROWS / 2)
three4thsLineCt     long    (screen.MAX_PHYSICAL_ROWS / 4) * 3

    end

    matrix.writePwmBuffer(pPwmFrameSet)
'}


VAR { spin pwm routein support }

    long    nRGBColorOffset
    long    currBitMask
    long    nColumnIndex
    long    nPysLineIndex
    long    nTargLineIndex
    long    nPwmRGB12ByteIndex
    long    isBottomHalf
    long    pPixColorAddr
    long    pPwmFrameBfr
    long    nQtrScanLenInBytes
    long    pPixScanline0Addr
    long    pPixColorAddrSL0
    long    pPwmFramePtrs[screen.MAX_PWM_FRAMES]
    long    one4thLineCount
    long    oneHalfLineCount
    long    three4thsLineCount
    byte    red, green, blue
    byte    rPwm, gPwm, bPwm
    byte    showConvertDetailCt

PUB convertScreen2PWM_14_spin(p24bitScreen, bSwapRB) | pPwmFrameSet, bitsBGR, nFrameOffset, nFrameIdx
    '' Load a 24-bit image into PWM frame buffers at 8s (4 scan-lines at a time) [SPIN]
    ' same loop but scan memory at 2 points, write PWM bytes once
    ' scanlines 0,1,2,3
    debug("- PNL:cs2pwm(): scn ", uhex_long(p24bitScreen), uhex_long(bSwapRB))

    ' -------------------------------------------------------------------------
    ' NOTES for panel P4-1921-8S-V2.0 - 1/8 scan
    '  two full 64px lines are emmitted for wach row, or 128px per each of 8 rows
    '  the top 16 rows are fed by RGB1, while the bottom 16 rows are fed by RGB2
    '
    '  64px lines do NOT span multiple rows! This means we can do a simple row-
    '  number translation when mapping our PWM buffers to how the panel will display
    '  the pixel values.
    '
    '  The mapping is as follows:
    '    ----- TOP ------                    ----- BOTTOM -----
    '  Row 0 is placed in PWM bffr Row 1    Row 16 into pwm Row 17
    '      1   ->   3                           17   ->   19
    '      2   ->   5                           18   ->   21
    '      3   ->   7                           19   ->   23
    '      4   ->   9                           20   ->   25
    '      5   ->  11                           21   ->   27
    '      6   ->  13                           22   ->   29
    '      7   ->  15                           23   ->   31
    '     ------------                          ------------
    '      8   ->   0                           24   ->   16
    '      9   ->   2                           25   ->   18
    '     10   ->   4                           26   ->   20
    '     11   ->   6                           27   ->   22
    '     12   ->   8                           28   ->   24
    '     13   ->  10                           29   ->   26
    '     14   ->  12                           30   ->   28
    '     15   ->  14                           31   ->   30
    ' -------------------------------------------------------------------------
    ' this routine does not prestore all the transformed bytes
    '  instead it scans each pixel at RC of the screen size
    '  it then places either RGB1 into the each pwm frames' buffer
    '   or if we are addressing the BOTTOM then it reads RGB1 value
    '   from the pwm frames' buffer and or's in the RGB2 values
    '
    '  THIS means that each screen buffer byte is read once while each
    '    PWM buffer byte is written twice.
    '  Anyway, the math to calculate the target pixel byte in the pwm buffer
    '   is:
    ' -------------------------------------------------------------------------
    '  The targetRow math of:
    '    rows  0 -  7: targetRow = (row * 2) + 1
    '    rows  8 - 15: targetRow = (row mod 8) * 2
    '    rows 16 - 24: targetRow = ((row - 16) * 2) + 17
    '    rows 24 - 31: targetRow = (row - 24) * 2) + 16
    ' -------------------------------------------------------------------------

    ' init ptrs
    pPwmFrameSet := getActivePwmBuffer()
    repeat nFrameIdx from 0 to screen.MAX_PWM_FRAMES - 1
        nFrameOffset := nFrameIdx * screen.MAX_PWM_FRAME_SIZE_IN_LONGS ' 256 longs in each frame
        pPwmFramePtrs[nFrameIdx] := @long[pPwmFrameSet][nFrameOffset]
        'debug("PNL: init PWM", udec_(nFrameIdx), ": ", uhex_long_(pPwmFramePtrs[nFrameIdx]))
    'debug("- PNL:convertScreen2PWM_14_spin(): ", uhex_long(p24bitScreen), uhex_long(pPwmFramePtrs[0]), uhex_long(pPwmFramePtrs[1]), "...", uhex_long(pPwmFramePtrs[screen.MAX_PWM_FRAMES - 1]))

    one4thLineCount := (screen.MAX_PHYSICAL_ROWS / 4)
    oneHalfLineCount := (screen.MAX_PHYSICAL_ROWS / 2)
    three4thsLineCount := one4thLineCount * 3
    ' for all pixels of the screen buffer
    repeat nPysLineIndex from 0 to screen.MAX_PHYSICAL_ROWS - 1             ' [0-31]
        repeat nColumnIndex from 0 to screen.MAX_PHYSICAL_COLUMNS - 1       ' [0-63]
            ' calc nRGBColorOffset: offset into screen buffer
            nRGBColorOffset := ((nPysLineIndex * screen.MAX_PHYSICAL_COLUMNS) + nColumnIndex) * screen.DISPLAY_BYTES_PER_COLOR
            ' calc nPwmRGB12ByteIndex: offset into PWM buffer
            if nPysLineIndex < one4thLineCount               ' [0-7]
                nTargLineIndex := (nPysLineIndex * 2) + 1
            elseif nPysLineIndex < oneHalfLineCount           ' [8-15]
                nTargLineIndex := (nPysLineIndex // one4thLineCount) * 2
            elseif nPysLineIndex < three4thsLineCount     ' [16-23]
                nTargLineIndex := ((nPysLineIndex - oneHalfLineCount) * 2) + oneHalfLineCount + 1
            else                                                            ' [24-31]
                nTargLineIndex := ((nPysLineIndex - three4thsLineCount) + oneHalfLineCount) * 2

            nPwmRGB12ByteIndex := (nTargLineIndex * screen.MAX_PHYSICAL_COLUMNS) + nColumnIndex
            isBottomHalf := (nTargLineIndex > oneHalfLineCount - 1) ? TRUE : FALSE
            ' now create a column/pixel index for this offset
            if nColumnIndex < 2 or nColumnIndex > 61
                debug("- PNL:cs2pwm(): srcR ", udec_long_(nPysLineIndex), ", trgR ", udec_long_(nTargLineIndex), ", col ", udec_long_(nColumnIndex), ", scnIdx ", udec_long_(nRGBColorOffset), ", pwmIdx ", udec_long_(nPwmRGB12ByteIndex))
                ' locate and load color for scanline
            pPixColorAddr := @byte[p24bitScreen][nRGBColorOffset]    ' add in offset to 24-bit color
            red := byte[pPixColorAddr][0]
            green := byte[pPixColorAddr][1]
            blue := byte[pPixColorAddr][2]
            if bSwapRB
                ' swap our red and blue
                rPwm := (blue > 0) ? bmask (blue - 1) : 0
                gPwm := (green > 0) ? bmask (green - 1) : 0
                bPwm := (red > 0) ? bmask (red - 1) : 0
            else
                ' no swap
                rPwm := (red > 0) ? bmask (red - 1) : 0
                gPwm := (green > 0) ? bmask (green - 1) : 0
                bPwm := (blue > 0) ? bmask (blue - 1) : 0

            repeat nFrameIdx from 0 to screen.MAX_PWM_FRAMES - 1
                ' calculate offset to frame for this bit #
                currBitMask := (1 << nFrameIdx)
                pPwmFrameBfr := pPwmFramePtrs[nFrameIdx]

                ' build top RGB1 or bottom RGB2 bits to be stored in panel byte
                if not isBottomHalf
                    bitsBGR := 0
                    bitsBGR |= (rPwm & currBitMask) > 0 ? 1 : 0
                    bitsBGR |= (gPwm & currBitMask) > 0 ? 2 : 0
                    bitsBGR |= (bPwm & currBitMask) > 0 ? 4 : 0
                else
                    bitsBGR := byte[pPwmFrameBfr][nPwmRGB12ByteIndex]
                    bitsBGR |= (rPwm & currBitMask) > 0 ? 8 : 0
                    bitsBGR |= (gPwm & currBitMask) > 0 ? $10 : 0
                    bitsBGR |= (bPwm & currBitMask) > 0 ? $20 : 0
                ' write RGB1, RGB2 value to byte
                byte[pPwmFrameBfr][nPwmRGB12ByteIndex] := bitsBGR

    matrix.writePwmBuffer(pPwmFrameSet)

' -----------------------------------------------------------------------------

PUB convertScreen2PWM(p24bitScreen, bSwapRB) | pPwmFrameSet
    '' Load a 24-bit image into PWM frame buffers at 16s, 32s (2 scan-lines at a time) [SPIN]
    ' XYZZYpnl debug("- PNL: loading screen at @", uhex_long_(p24bitScreen))
    ' FACT: dual 64x64 panel yields 205.035 Hz (full PWM fps)
    ' save address of 24bit screen for use by called routines
    pScreenInMemory := p24bitScreen
  ' clear 8x 3-bit frames
    pPwmFrameSet := clearPwmFrameBuffer()  ' clear PWM frames  and get pointer to buffer

   ' fill 8x 3-bit frames from 24-bit-screen
    org
                    ' for each pixels in half screen...
                    add     p24bitColorTop, p24bitScreen                        ' convert to address of last pixel in top half
                    add     p24bitColorBot, p24bitColorTop                      ' convert to address of last pixel in bottom half
                    ' setup for red/blue flip if needed
                    or      bSwapRB, bSwapRB   wz
    if_nz           mov     redBitTopValue, #$04
    if_nz           mov     blueBitTopValue, #$01
    if_z            mov     redBitTopValue, #$01
    if_z            mov     blueBitTopValue, #$04
    if_nz           mov     redBitBotValue, #$20
    if_nz           mov     blueBitBotValue, #$08
    if_z            mov     redBitBotValue, #$08
    if_z            mov     blueBitBotValue, #$20
nextPixel
                    ' load our 2 pixels color/pwm data (top and bottom half of panel)
                    rdlong  colorValue24bit, p24bitColorTop
                    ' red := byte[p24bitScreen][p24bitColor][0]
                    getbyte currPwmBits, colorValue24bit,#0
                    call    #cvtCurr2pwm
                    mov     redPwmBitsTop, currPwmBits
                    ' green := byte[p24bitScreen][p24bitColor][1]
                    getbyte currPwmBits, colorValue24bit,#1
                    call    #cvtCurr2pwm
                    mov     greenPwmBitsTop, currPwmBits
                    ' blue := byte[p24bitScreen][p24bitColor][2]
                    getbyte currPwmBits, colorValue24bit,#2
                    call    #cvtCurr2pwm
                    mov     bluePwmBitsTop, currPwmBits

                    rdlong  colorValue24bit, p24bitColorBot
                    ' red := byte[p24bitScreen][p24bitColor][0]
                    getbyte currPwmBits, colorValue24bit,#0
                    call    #cvtCurr2pwm
                    mov     redPwmBitsBot, currPwmBits
                    ' green := byte[p24bitScreen][p24bitColor][1]
                    getbyte currPwmBits, colorValue24bit,#1
                    call    #cvtCurr2pwm
                    mov     greenPwmBitsBot, currPwmBits
                    ' blue := byte[p24bitScreen][p24bitColor][2]
                    getbyte currPwmBits, colorValue24bit,#2
                    call    #cvtCurr2pwm
                    mov     bluePwmBitsBot, currPwmBits

                    ' FYI GAMMA correction, brightness are adjusted as the byte is place into our source screen buffer!!

                    ' write color information to our PWM buffers
                    ' expand 24-bit pixel into 8 pwm frames of 3-bit pixel
                    ' for ea. bit do...
                    mov     bitCount, #screen.MAX_PWM_FRAMES        ' MAX PWM FRAME bits to scan in LONG
                    mov     currBitNumber, #0                           ' start with bit0 of [0-MAX_PWM_FRAMES - 1]
nextBit
                    ' calculate offset to frame for this bit #
                    '   frameIdx := 0 #> nBitNumber <# screen.MAX_PWM_FRAMES - 1    ' MAX 8 pwm frames so limit our index
                    '   nFrameOffset := frameIdx * screen.MAX_PWM_FRAME_SIZE_IN_LONGS ' 256 longs in each frame
                    '   pPwmFrameByt := @long[getActivePwmBuffer()][nFrameOffset]
                    mov     pPwmFrameByt, currBitNumber
                    mul     pPwmFrameByt, ##screen.MAX_PWM_FRAME_SIZE_IN_BYTES
                    ' calculate pointer to frame for this bit #
                    add     pPwmFrameByt, pPwmFrameSet     ' add base of frame buffer
                    add     pPwmFrameByt, nPixelCtr        ' add-in offset to current byte
                    sub     pPwmFrameByt, #1               ' make relative to 0
                    ' build RGB1 and RGB2 bits to be stored in PWM panel byte
                    '   rBit := red & (1 << currBitNumber) > 0 ? 1 : 0
                    '   gBit := green & (1 << currBitNumber) > 0 ? 1 : 0
                    '   bBit := blue & (1 << currBitNumber) > 0 ? 1 : 0
                    mov     panelBGR, #0                    ' clear color value
                    testb   redPwmBitsTop, currBitNumber     wc
        if_c        or      panelBGR, redBitTopValue
                    testb   greenPwmBitsTop, currBitNumber   wc
        if_c        or      panelBGR, greenBitTopValue
                    testb   bluePwmBitsTop, currBitNumber    wc
        if_c        or      panelBGR, blueBitTopValue
                    testb   redPwmBitsBot, currBitNumber     wc
        if_c        or      panelBGR, redBitBotValue
                    testb   greenPwmBitsBot, currBitNumber   wc
        if_c        or      panelBGR, greenBitBotValue
                    testb   bluePwmBitsBot, currBitNumber    wc
        if_c        or      panelBGR, blueBitBotValue

                    ' write our new byte value
                    '    byte[pPwmFrameByt][pwmByteIndex] := panelBGR
                    wrbyte  panelBGR, pPwmFrameByt
                    ' this one done, if not all 8 bits done, go do next
                    add     currBitNumber, #1
                    djnz    bitCount, #nextBit

                    ' point to prior pixel RGB spec in top and bottom halves
                    sub    p24bitColorTop, #screen.DISPLAY_BYTES_PER_COLOR
                    sub    p24bitColorBot, #screen.DISPLAY_BYTES_PER_COLOR
                    ' count this pixel done, go do next pixel if not yet done
                    djnz    nPixelCtr, #nextPixel
                    jmp     #done

' currPwmBits := cvtCurr2pwm(currPwmBits)   ' NOTE wipes tempByte
cvtCurr2pwm
                    or      currPwmBits, currPwmBits    wz  ' special case: if zero return all 0 bits
        if_z        ret
                    sub     currPwmBits, #1                 ' subtract 1 from our count
                    bmask   currPwmBits, currPwmBits        ' convert bit count into string of bits
                    ret
done

' the following initialized values are simply copied into PASM area before routine is run
nPixelCtr           long    (screen.MAX_PHYSICAL_ROWS * screen.MAX_PHYSICAL_COLUMNS) / 2
redBitTopValue      long    $01
greenBitTopValue    long    $02
blueBitTopValue     long    $04
redBitBotValue      long    $08
greenBitBotValue    long    $10
blueBitBotValue     long    $20
midDisplayRow       long    0
redPwmBitsTop       long    0
greenPwmBitsTop     long    0
bluePwmBitsTop      long    0
redPwmBitsBot       long    0
greenPwmBitsBot     long    0
bluePwmBitsBot      long    0
pPwmFrameByt        long    0
p24bitColorTop      long    (((screen.MAX_PHYSICAL_ROWS * screen.MAX_PHYSICAL_COLUMNS) / 2) - 1) * screen.DISPLAY_BYTES_PER_COLOR
p24bitColorBot      long    ((screen.MAX_PHYSICAL_ROWS * screen.MAX_PHYSICAL_COLUMNS) / 2) * screen.DISPLAY_BYTES_PER_COLOR
colorValue24bit     long    0
colorValueTop       long    0
colorValueBot       long    0
colorMask           long    0
bitCount            long    0
currBitNumber       long    0
panelBGR            long    0
rowIndexHalfPanel   long    0
pwmByteIndex        long    0
currPwmColorBits    long    0
currPwmBits         long    0
tempByte            long    0
allOnes             long    $ffffffff

    end

    matrix.writePwmBuffer(pPwmFrameSet)


PRI dumpBufferHeads(pSCreenBuffer,pPwmBuffer)
    screen.dbgMemDump(@bufferMsg, pSCreenBuffer, 48)
    screen.dbgMemDump(@frameMsg, pPwmBuffer, 48)

PRI dumpFrameAddrs(pPwmFrameSet) | pFrameBuffer, frameIndex
        repeat frameIndex from 0 to screen.MAX_PWM_FRAMES - 1
            pFrameBuffer := @long[pPwmFrameSet][frameIndex * screen.MAX_PWM_FRAME_SIZE_IN_LONGS]
            debug("PNL: PWM", udec_(frameIndex), ": ", uhex_long_(pFrameBuffer))

PRI dumpFrameSet(pPwmFrameSet) | pFrameBuffer, frameIndex
        repeat frameIndex from 0 to screen.MAX_PWM_FRAMES - 1
            pFrameBuffer := @long[pPwmFrameSet][frameIndex * screen.MAX_PWM_FRAME_SIZE_IN_LONGS]
            dumpFrame(pFrameBuffer)

PRI dumpFrame(pFrameBuffer)
    screen.dbgMemDump(@frameMessage, pFrameBuffer, 16)

PRI clearPwmFrameBuffer() : pPwmFrameSet
    ' clear entire PWM buffer
    ' implement double buffering by alternating between our two pwm-frame-sets
    usePwmFrameset1 := !usePwmFrameset1
    pPwmFrameSet := getActivePwmBuffer()
    'debug("- active buffer=", uhex_long_(pPwmFrameSet))
    longfill(pPwmFrameSet, 0, screen.MAX_PWM_FRAME_SIZE_IN_LONGS * screen.MAX_PWM_FRAMES)

PRI getActivePwmBuffer() : pPwmFrameSet
    pPwmFrameSet := (usePwmFrameset1) ? @pwmFrames1 : @pwmFrames2

PRI getPwmFrameAddressForBit(nBitNumber) : pFrameBuffer | nFrameOfst, frameIdx
    ' return indexed PWM Frame address
    frameIdx := 0 #> nBitNumber <# screen.MAX_PWM_FRAMES - 1    ' limit our index to MAX_PWM_FRAMES
    nFrameOfst := frameIdx * screen.MAX_PWM_FRAME_SIZE_IN_LONGS ' N longs in each PWM frame
    pFrameBuffer := @long[getActivePwmBuffer()][nFrameOfst]
    'debug("- PWM frame(", udec_(frameIdx), "), ", uhex_long(pFrameBuffer))

VAR { buffer addresses }

    long    pBitmapFileInMemory
    long    dvrConfig
    long    driverConfigRaw
    long    pScreenInMemory

PRI setPanelColorBitsForRC(pPwmFrame, nPanelRow, nPanelCol, rBit, gBit, bBit) | nBffrR, nBffrC, isRGB2, byteIdx, maskBitsBGR, bitsBGR, currPwmColorBits, showDebug
    '  write color bits to a PWM frame at frame[r][c]
    nBffrR := 0 #> nPanelRow <# screen.MAX_PHYSICAL_ROWS - 1
    nBffrC := 0 #> nPanelCol <# screen.MAX_PHYSICAL_COLUMNS - 1
    isRGB2 := (nBffrR > 15) ? TRUE : FALSE
    nBffrR //= 16

    maskBitsBGR := %0000_0111
    ' NOTE: our hardware uses "00 bgr bgr" for the byte value!
    bitsBGR := ((bBit & $01) << 2) | ((gBit & $01) << 1) | (rBit & $01)
    if isRGB2
        bitsBGR <<= 3    ' mov color bits into rgb2 position
        maskBitsBGR <<= 3
    ' FIXME: UNDONE WAS PANEL_COLUMNS ??
    byteIdx := (nBffrR * screen.MAX_PHYSICAL_COLUMNS) + nBffrC

    currPwmColorBits := byte[pPwmFrame][byteIdx] & !maskBitsBGR
    if byteIdx > 1023
        debug("ERROR! byte index calc failure have=(" , udec_(byteIdx), ") of [0-1023]")
    else
        byte[pPwmFrame][byteIdx] := currPwmColorBits | bitsBGR


PRI isDebugLocn(nRow, nCol) : status
    status := FALSE
    return
    if (nRow == 31 && nCol < 4) || (nRow < 2 && nCol < 3) || (nRow == 31 && nCol > 61) || (nRow < 2 && nCol > 61)
        status := TRUE ' FALSE  ' turn off debug


DAT { .bmp fiile work area }

    testValue           long    $87654321
    testValueMsg       byte    "Test value",0

    frameMessage       byte    "FrameBuffer",0

    msgScrnHd   byte "Screen",0
    msgPwm0     byte    "Pwm0", 0
    msgPwm1     byte    "Pwm1", 0
    msgPwm2     byte    "Pwm2", 0
    msgPwm3     byte    "Pwm3", 0
    msgPwm4     byte    "Pwm4", 0
    msgPwm5     byte    "Pwm5", 0

    bufferMsg   byte    "SCREEN",0
    frameMsg   byte    "PWM[0]",0

CON { license }

{{


 -------------------------------------------------------------------------------------------------
  MIT License

  Copyright (c) 2020 Iron Sheep Productions, LLC

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
 =================================================================================================

}}
